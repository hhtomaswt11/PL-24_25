Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    APOSTROPHE
    CASE
    COMMENT
    CONST
    FILE
    GOTO
    LABEL
    NIL
    PACKED
    READ
    RECORD
    REPEAT
    RETURN
    SET
    TYPE
    UNTIL
    WITH
    WRITE

Grammar

Rule 0     S' -> program
Rule 1     program -> PROGRAM ID SEMICOLON block PERIOD
Rule 2     block -> declarations compound_statement
Rule 3     declarations -> declaration declarations
Rule 4     declarations -> empty
Rule 5     declaration -> VAR var_declarations
Rule 6     declaration -> function_declaration
Rule 7     declaration -> procedure_declaration
Rule 8     function_block -> declarations compound_statement
Rule 9     function_block -> compound_statement
Rule 10    function_declaration -> FUNCTION ID LPAREN param_list RPAREN COLON type_spec SEMICOLON function_block SEMICOLON
Rule 11    function_declaration -> FUNCTION ID COLON type_spec SEMICOLON function_block SEMICOLON
Rule 12    procedure_declaration -> PROCEDURE ID LPAREN param_list RPAREN SEMICOLON function_block SEMICOLON
Rule 13    procedure_declaration -> PROCEDURE ID SEMICOLON function_block SEMICOLON
Rule 14    var_declarations -> var_declarations var_declaration
Rule 15    var_declarations -> var_declaration
Rule 16    var_declaration -> id_list COLON type_spec SEMICOLON
Rule 17    id_list -> id_list COMMA ID
Rule 18    id_list -> ID
Rule 19    type_spec -> INTEGER_TYPE
Rule 20    type_spec -> REAL_TYPE
Rule 21    type_spec -> BOOLEAN
Rule 22    type_spec -> STRING_TYPE
Rule 23    type_spec -> CHAR_TYPE
Rule 24    type_spec -> array_type
Rule 25    array_type -> ARRAY LBRACKET INTEGER PERIOD PERIOD INTEGER RBRACKET OF type_spec
Rule 26    compound_statement -> BEGIN statement_list END
Rule 27    statement_list -> statement_list SEMICOLON statement
Rule 28    statement_list -> statement
Rule 29    statement -> compound_statement
Rule 30    statement -> assignment_statement
Rule 31    statement -> if_statement
Rule 32    statement -> while_statement
Rule 33    statement -> for_statement
Rule 34    statement -> procedure_call_statement
Rule 35    statement -> function_call_statement
Rule 36    statement -> halt_statement
Rule 37    statement -> empty
Rule 38    assignment_statement -> variable ASSIGN expression
Rule 39    assignment_statement -> ID ASSIGN expression
Rule 40    variable -> ID
Rule 41    variable -> ID LBRACKET expression RBRACKET
Rule 42    if_statement -> IF expression THEN statement
Rule 43    if_statement -> IF expression THEN statement ELSE statement
Rule 44    while_statement -> WHILE expression DO statement
Rule 45    for_statement -> FOR ID ASSIGN expression TO expression DO statement
Rule 46    for_statement -> FOR ID ASSIGN expression DOWNTO expression DO statement
Rule 47    procedure_call_statement -> ID LPAREN expression_list RPAREN
Rule 48    procedure_call_statement -> ID LPAREN RPAREN
Rule 49    procedure_call_statement -> WRITELN LPAREN expression_list RPAREN
Rule 50    procedure_call_statement -> WRITELN LPAREN RPAREN
Rule 51    procedure_call_statement -> READLN LPAREN variable RPAREN
Rule 52    procedure_call_statement -> READLN LPAREN RPAREN
Rule 53    function_call_statement -> function_call
Rule 54    expression_list -> expression_list COMMA expression
Rule 55    expression_list -> expression
Rule 56    param_list -> param_list SEMICOLON param
Rule 57    param_list -> param
Rule 58    param_list -> empty
Rule 59    param -> id_list COLON type_spec
Rule 60    param -> VAR id_list COLON type_spec
Rule 61    expression -> simple_expression
Rule 62    expression -> simple_expression relop simple_expression
Rule 63    relop -> EQ
Rule 64    relop -> NEQ
Rule 65    relop -> LT
Rule 66    relop -> LE
Rule 67    relop -> GT
Rule 68    relop -> GE
Rule 69    relop -> IN
Rule 70    simple_expression -> term
Rule 71    simple_expression -> simple_expression addop term
Rule 72    addop -> PLUS
Rule 73    addop -> MINUS
Rule 74    addop -> OR
Rule 75    term -> factor
Rule 76    term -> term mulop factor
Rule 77    mulop -> TIMES
Rule 78    mulop -> DIVIDE
Rule 79    mulop -> DIV
Rule 80    mulop -> MOD
Rule 81    mulop -> AND
Rule 82    factor -> string_access
Rule 83    factor -> variable
Rule 84    factor -> INTEGER
Rule 85    factor -> REAL
Rule 86    factor -> STRING
Rule 87    factor -> TRUE
Rule 88    factor -> FALSE
Rule 89    factor -> LPAREN expression RPAREN
Rule 90    factor -> NOT factor
Rule 91    factor -> function_call
Rule 92    string_access -> ID LBRACKET expression RBRACKET
Rule 93    expression -> variable COLON INTEGER
Rule 94    expression -> variable COLON INTEGER COLON INTEGER
Rule 95    function_call -> ID LPAREN expression_list RPAREN
Rule 96    function_call -> ID LPAREN RPAREN
Rule 97    function_call -> LENGTH LPAREN expression RPAREN
Rule 98    halt_statement -> HALT
Rule 99    empty -> <empty>

Terminals, with rules where they appear

AND                  : 81
APOSTROPHE           : 
ARRAY                : 25
ASSIGN               : 38 39 45 46
BEGIN                : 26
BOOLEAN              : 21
CASE                 : 
CHAR_TYPE            : 23
COLON                : 10 11 16 59 60 93 94 94
COMMA                : 17 54
COMMENT              : 
CONST                : 
DIV                  : 79
DIVIDE               : 78
DO                   : 44 45 46
DOWNTO               : 46
ELSE                 : 43
END                  : 26
EQ                   : 63
FALSE                : 88
FILE                 : 
FOR                  : 45 46
FUNCTION             : 10 11
GE                   : 68
GOTO                 : 
GT                   : 67
HALT                 : 98
ID                   : 1 10 11 12 13 17 18 39 40 41 45 46 47 48 92 95 96
IF                   : 42 43
IN                   : 69
INTEGER              : 25 25 84 93 94 94
INTEGER_TYPE         : 19
LABEL                : 
LBRACKET             : 25 41 92
LE                   : 66
LENGTH               : 97
LPAREN               : 10 12 47 48 49 50 51 52 89 95 96 97
LT                   : 65
MINUS                : 73
MOD                  : 80
NEQ                  : 64
NIL                  : 
NOT                  : 90
OF                   : 25
OR                   : 74
PACKED               : 
PERIOD               : 1 25 25
PLUS                 : 72
PROCEDURE            : 12 13
PROGRAM              : 1
RBRACKET             : 25 41 92
READ                 : 
READLN               : 51 52
REAL                 : 85
REAL_TYPE            : 20
RECORD               : 
REPEAT               : 
RETURN               : 
RPAREN               : 10 12 47 48 49 50 51 52 89 95 96 97
SEMICOLON            : 1 10 10 11 11 12 12 13 13 16 27 56
SET                  : 
STRING               : 86
STRING_TYPE          : 22
THEN                 : 42 43
TIMES                : 77
TO                   : 45
TRUE                 : 87
TYPE                 : 
UNTIL                : 
VAR                  : 5 60
WHILE                : 44
WITH                 : 
WRITE                : 
WRITELN              : 49 50
error                : 

Nonterminals, with rules where they appear

addop                : 71
array_type           : 24
assignment_statement : 30
block                : 1
compound_statement   : 2 8 9 29
declaration          : 3
declarations         : 2 3 8
empty                : 4 37 58
expression           : 38 39 41 42 43 44 45 45 46 46 54 55 89 92 97
expression_list      : 47 49 54 95
factor               : 75 76 90
for_statement        : 33
function_block       : 10 11 12 13
function_call        : 53 91
function_call_statement : 35
function_declaration : 6
halt_statement       : 36
id_list              : 16 17 59 60
if_statement         : 31
mulop                : 76
param                : 56 57
param_list           : 10 12 56
procedure_call_statement : 34
procedure_declaration : 7
program              : 0
relop                : 62
simple_expression    : 61 62 62 71
statement            : 27 28 42 43 43 44 45 46
statement_list       : 26 27
string_access        : 82
term                 : 70 71 76
type_spec            : 10 11 16 25 59 60
var_declaration      : 14 15
var_declarations     : 5 14
variable             : 38 51 83 93 94
while_statement      : 32

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . PROGRAM ID SEMICOLON block PERIOD

    PROGRAM         shift and go to state 2

    program                        shift and go to state 1

state 1

    (0) S' -> program .



state 2

    (1) program -> PROGRAM . ID SEMICOLON block PERIOD

    ID              shift and go to state 3


state 3

    (1) program -> PROGRAM ID . SEMICOLON block PERIOD

    SEMICOLON       shift and go to state 4


state 4

    (1) program -> PROGRAM ID SEMICOLON . block PERIOD
    (2) block -> . declarations compound_statement
    (3) declarations -> . declaration declarations
    (4) declarations -> . empty
    (5) declaration -> . VAR var_declarations
    (6) declaration -> . function_declaration
    (7) declaration -> . procedure_declaration
    (99) empty -> .
    (10) function_declaration -> . FUNCTION ID LPAREN param_list RPAREN COLON type_spec SEMICOLON function_block SEMICOLON
    (11) function_declaration -> . FUNCTION ID COLON type_spec SEMICOLON function_block SEMICOLON
    (12) procedure_declaration -> . PROCEDURE ID LPAREN param_list RPAREN SEMICOLON function_block SEMICOLON
    (13) procedure_declaration -> . PROCEDURE ID SEMICOLON function_block SEMICOLON

    VAR             shift and go to state 9
    BEGIN           reduce using rule 99 (empty -> .)
    FUNCTION        shift and go to state 12
    PROCEDURE       shift and go to state 13

    block                          shift and go to state 5
    declarations                   shift and go to state 6
    declaration                    shift and go to state 7
    empty                          shift and go to state 8
    function_declaration           shift and go to state 10
    procedure_declaration          shift and go to state 11

state 5

    (1) program -> PROGRAM ID SEMICOLON block . PERIOD

    PERIOD          shift and go to state 14


state 6

    (2) block -> declarations . compound_statement
    (26) compound_statement -> . BEGIN statement_list END

    BEGIN           shift and go to state 16

    compound_statement             shift and go to state 15

state 7

    (3) declarations -> declaration . declarations
    (3) declarations -> . declaration declarations
    (4) declarations -> . empty
    (5) declaration -> . VAR var_declarations
    (6) declaration -> . function_declaration
    (7) declaration -> . procedure_declaration
    (99) empty -> .
    (10) function_declaration -> . FUNCTION ID LPAREN param_list RPAREN COLON type_spec SEMICOLON function_block SEMICOLON
    (11) function_declaration -> . FUNCTION ID COLON type_spec SEMICOLON function_block SEMICOLON
    (12) procedure_declaration -> . PROCEDURE ID LPAREN param_list RPAREN SEMICOLON function_block SEMICOLON
    (13) procedure_declaration -> . PROCEDURE ID SEMICOLON function_block SEMICOLON

    VAR             shift and go to state 9
    BEGIN           reduce using rule 99 (empty -> .)
    FUNCTION        shift and go to state 12
    PROCEDURE       shift and go to state 13

    declaration                    shift and go to state 7
    declarations                   shift and go to state 17
    empty                          shift and go to state 8
    function_declaration           shift and go to state 10
    procedure_declaration          shift and go to state 11

state 8

    (4) declarations -> empty .

    BEGIN           reduce using rule 4 (declarations -> empty .)


state 9

    (5) declaration -> VAR . var_declarations
    (14) var_declarations -> . var_declarations var_declaration
    (15) var_declarations -> . var_declaration
    (16) var_declaration -> . id_list COLON type_spec SEMICOLON
    (17) id_list -> . id_list COMMA ID
    (18) id_list -> . ID

    ID              shift and go to state 21

    var_declarations               shift and go to state 18
    var_declaration                shift and go to state 19
    id_list                        shift and go to state 20

state 10

    (6) declaration -> function_declaration .

    VAR             reduce using rule 6 (declaration -> function_declaration .)
    FUNCTION        reduce using rule 6 (declaration -> function_declaration .)
    PROCEDURE       reduce using rule 6 (declaration -> function_declaration .)
    BEGIN           reduce using rule 6 (declaration -> function_declaration .)


state 11

    (7) declaration -> procedure_declaration .

    VAR             reduce using rule 7 (declaration -> procedure_declaration .)
    FUNCTION        reduce using rule 7 (declaration -> procedure_declaration .)
    PROCEDURE       reduce using rule 7 (declaration -> procedure_declaration .)
    BEGIN           reduce using rule 7 (declaration -> procedure_declaration .)


state 12

    (10) function_declaration -> FUNCTION . ID LPAREN param_list RPAREN COLON type_spec SEMICOLON function_block SEMICOLON
    (11) function_declaration -> FUNCTION . ID COLON type_spec SEMICOLON function_block SEMICOLON

    ID              shift and go to state 22


state 13

    (12) procedure_declaration -> PROCEDURE . ID LPAREN param_list RPAREN SEMICOLON function_block SEMICOLON
    (13) procedure_declaration -> PROCEDURE . ID SEMICOLON function_block SEMICOLON

    ID              shift and go to state 23


state 14

    (1) program -> PROGRAM ID SEMICOLON block PERIOD .

    $end            reduce using rule 1 (program -> PROGRAM ID SEMICOLON block PERIOD .)


state 15

    (2) block -> declarations compound_statement .

    PERIOD          reduce using rule 2 (block -> declarations compound_statement .)


state 16

    (26) compound_statement -> BEGIN . statement_list END
    (27) statement_list -> . statement_list SEMICOLON statement
    (28) statement_list -> . statement
    (29) statement -> . compound_statement
    (30) statement -> . assignment_statement
    (31) statement -> . if_statement
    (32) statement -> . while_statement
    (33) statement -> . for_statement
    (34) statement -> . procedure_call_statement
    (35) statement -> . function_call_statement
    (36) statement -> . halt_statement
    (37) statement -> . empty
    (26) compound_statement -> . BEGIN statement_list END
    (38) assignment_statement -> . variable ASSIGN expression
    (39) assignment_statement -> . ID ASSIGN expression
    (42) if_statement -> . IF expression THEN statement
    (43) if_statement -> . IF expression THEN statement ELSE statement
    (44) while_statement -> . WHILE expression DO statement
    (45) for_statement -> . FOR ID ASSIGN expression TO expression DO statement
    (46) for_statement -> . FOR ID ASSIGN expression DOWNTO expression DO statement
    (47) procedure_call_statement -> . ID LPAREN expression_list RPAREN
    (48) procedure_call_statement -> . ID LPAREN RPAREN
    (49) procedure_call_statement -> . WRITELN LPAREN expression_list RPAREN
    (50) procedure_call_statement -> . WRITELN LPAREN RPAREN
    (51) procedure_call_statement -> . READLN LPAREN variable RPAREN
    (52) procedure_call_statement -> . READLN LPAREN RPAREN
    (53) function_call_statement -> . function_call
    (98) halt_statement -> . HALT
    (99) empty -> .
    (40) variable -> . ID
    (41) variable -> . ID LBRACKET expression RBRACKET
    (95) function_call -> . ID LPAREN expression_list RPAREN
    (96) function_call -> . ID LPAREN RPAREN
    (97) function_call -> . LENGTH LPAREN expression RPAREN

    BEGIN           shift and go to state 16
    ID              shift and go to state 36
    IF              shift and go to state 37
    WHILE           shift and go to state 38
    FOR             shift and go to state 39
    WRITELN         shift and go to state 40
    READLN          shift and go to state 41
    HALT            shift and go to state 43
    END             reduce using rule 99 (empty -> .)
    SEMICOLON       reduce using rule 99 (empty -> .)
    LENGTH          shift and go to state 44

    statement_list                 shift and go to state 24
    statement                      shift and go to state 25
    compound_statement             shift and go to state 26
    assignment_statement           shift and go to state 27
    if_statement                   shift and go to state 28
    while_statement                shift and go to state 29
    for_statement                  shift and go to state 30
    procedure_call_statement       shift and go to state 31
    function_call_statement        shift and go to state 32
    halt_statement                 shift and go to state 33
    empty                          shift and go to state 34
    variable                       shift and go to state 35
    function_call                  shift and go to state 42

state 17

    (3) declarations -> declaration declarations .

    BEGIN           reduce using rule 3 (declarations -> declaration declarations .)


state 18

    (5) declaration -> VAR var_declarations .
    (14) var_declarations -> var_declarations . var_declaration
    (16) var_declaration -> . id_list COLON type_spec SEMICOLON
    (17) id_list -> . id_list COMMA ID
    (18) id_list -> . ID

    VAR             reduce using rule 5 (declaration -> VAR var_declarations .)
    FUNCTION        reduce using rule 5 (declaration -> VAR var_declarations .)
    PROCEDURE       reduce using rule 5 (declaration -> VAR var_declarations .)
    BEGIN           reduce using rule 5 (declaration -> VAR var_declarations .)
    ID              shift and go to state 21

    var_declaration                shift and go to state 45
    id_list                        shift and go to state 20

state 19

    (15) var_declarations -> var_declaration .

    ID              reduce using rule 15 (var_declarations -> var_declaration .)
    VAR             reduce using rule 15 (var_declarations -> var_declaration .)
    FUNCTION        reduce using rule 15 (var_declarations -> var_declaration .)
    PROCEDURE       reduce using rule 15 (var_declarations -> var_declaration .)
    BEGIN           reduce using rule 15 (var_declarations -> var_declaration .)


state 20

    (16) var_declaration -> id_list . COLON type_spec SEMICOLON
    (17) id_list -> id_list . COMMA ID

    COLON           shift and go to state 46
    COMMA           shift and go to state 47


state 21

    (18) id_list -> ID .

    COLON           reduce using rule 18 (id_list -> ID .)
    COMMA           reduce using rule 18 (id_list -> ID .)


state 22

    (10) function_declaration -> FUNCTION ID . LPAREN param_list RPAREN COLON type_spec SEMICOLON function_block SEMICOLON
    (11) function_declaration -> FUNCTION ID . COLON type_spec SEMICOLON function_block SEMICOLON

    LPAREN          shift and go to state 48
    COLON           shift and go to state 49


state 23

    (12) procedure_declaration -> PROCEDURE ID . LPAREN param_list RPAREN SEMICOLON function_block SEMICOLON
    (13) procedure_declaration -> PROCEDURE ID . SEMICOLON function_block SEMICOLON

    LPAREN          shift and go to state 50
    SEMICOLON       shift and go to state 51


state 24

    (26) compound_statement -> BEGIN statement_list . END
    (27) statement_list -> statement_list . SEMICOLON statement

    END             shift and go to state 52
    SEMICOLON       shift and go to state 53


state 25

    (28) statement_list -> statement .

    END             reduce using rule 28 (statement_list -> statement .)
    SEMICOLON       reduce using rule 28 (statement_list -> statement .)


state 26

    (29) statement -> compound_statement .

    END             reduce using rule 29 (statement -> compound_statement .)
    SEMICOLON       reduce using rule 29 (statement -> compound_statement .)
    ELSE            reduce using rule 29 (statement -> compound_statement .)


state 27

    (30) statement -> assignment_statement .

    END             reduce using rule 30 (statement -> assignment_statement .)
    SEMICOLON       reduce using rule 30 (statement -> assignment_statement .)
    ELSE            reduce using rule 30 (statement -> assignment_statement .)


state 28

    (31) statement -> if_statement .

    END             reduce using rule 31 (statement -> if_statement .)
    SEMICOLON       reduce using rule 31 (statement -> if_statement .)
    ELSE            reduce using rule 31 (statement -> if_statement .)


state 29

    (32) statement -> while_statement .

    END             reduce using rule 32 (statement -> while_statement .)
    SEMICOLON       reduce using rule 32 (statement -> while_statement .)
    ELSE            reduce using rule 32 (statement -> while_statement .)


state 30

    (33) statement -> for_statement .

    END             reduce using rule 33 (statement -> for_statement .)
    SEMICOLON       reduce using rule 33 (statement -> for_statement .)
    ELSE            reduce using rule 33 (statement -> for_statement .)


state 31

    (34) statement -> procedure_call_statement .

    END             reduce using rule 34 (statement -> procedure_call_statement .)
    SEMICOLON       reduce using rule 34 (statement -> procedure_call_statement .)
    ELSE            reduce using rule 34 (statement -> procedure_call_statement .)


state 32

    (35) statement -> function_call_statement .

    END             reduce using rule 35 (statement -> function_call_statement .)
    SEMICOLON       reduce using rule 35 (statement -> function_call_statement .)
    ELSE            reduce using rule 35 (statement -> function_call_statement .)


state 33

    (36) statement -> halt_statement .

    END             reduce using rule 36 (statement -> halt_statement .)
    SEMICOLON       reduce using rule 36 (statement -> halt_statement .)
    ELSE            reduce using rule 36 (statement -> halt_statement .)


state 34

    (37) statement -> empty .

    END             reduce using rule 37 (statement -> empty .)
    SEMICOLON       reduce using rule 37 (statement -> empty .)
    ELSE            reduce using rule 37 (statement -> empty .)


state 35

    (38) assignment_statement -> variable . ASSIGN expression

    ASSIGN          shift and go to state 54


state 36

    (39) assignment_statement -> ID . ASSIGN expression
    (47) procedure_call_statement -> ID . LPAREN expression_list RPAREN
    (48) procedure_call_statement -> ID . LPAREN RPAREN
    (40) variable -> ID .
    (41) variable -> ID . LBRACKET expression RBRACKET
    (95) function_call -> ID . LPAREN expression_list RPAREN
    (96) function_call -> ID . LPAREN RPAREN

  ! shift/reduce conflict for ASSIGN resolved as shift
    ASSIGN          shift and go to state 55
    LPAREN          shift and go to state 56
    LBRACKET        shift and go to state 57

  ! ASSIGN          [ reduce using rule 40 (variable -> ID .) ]


state 37

    (42) if_statement -> IF . expression THEN statement
    (43) if_statement -> IF . expression THEN statement ELSE statement
    (61) expression -> . simple_expression
    (62) expression -> . simple_expression relop simple_expression
    (93) expression -> . variable COLON INTEGER
    (94) expression -> . variable COLON INTEGER COLON INTEGER
    (70) simple_expression -> . term
    (71) simple_expression -> . simple_expression addop term
    (40) variable -> . ID
    (41) variable -> . ID LBRACKET expression RBRACKET
    (75) term -> . factor
    (76) term -> . term mulop factor
    (82) factor -> . string_access
    (83) factor -> . variable
    (84) factor -> . INTEGER
    (85) factor -> . REAL
    (86) factor -> . STRING
    (87) factor -> . TRUE
    (88) factor -> . FALSE
    (89) factor -> . LPAREN expression RPAREN
    (90) factor -> . NOT factor
    (91) factor -> . function_call
    (92) string_access -> . ID LBRACKET expression RBRACKET
    (95) function_call -> . ID LPAREN expression_list RPAREN
    (96) function_call -> . ID LPAREN RPAREN
    (97) function_call -> . LENGTH LPAREN expression RPAREN

    ID              shift and go to state 63
    INTEGER         shift and go to state 61
    REAL            shift and go to state 66
    STRING          shift and go to state 67
    TRUE            shift and go to state 68
    FALSE           shift and go to state 69
    LPAREN          shift and go to state 70
    NOT             shift and go to state 71
    LENGTH          shift and go to state 44

    expression                     shift and go to state 58
    simple_expression              shift and go to state 59
    variable                       shift and go to state 60
    term                           shift and go to state 62
    factor                         shift and go to state 64
    string_access                  shift and go to state 65
    function_call                  shift and go to state 72

state 38

    (44) while_statement -> WHILE . expression DO statement
    (61) expression -> . simple_expression
    (62) expression -> . simple_expression relop simple_expression
    (93) expression -> . variable COLON INTEGER
    (94) expression -> . variable COLON INTEGER COLON INTEGER
    (70) simple_expression -> . term
    (71) simple_expression -> . simple_expression addop term
    (40) variable -> . ID
    (41) variable -> . ID LBRACKET expression RBRACKET
    (75) term -> . factor
    (76) term -> . term mulop factor
    (82) factor -> . string_access
    (83) factor -> . variable
    (84) factor -> . INTEGER
    (85) factor -> . REAL
    (86) factor -> . STRING
    (87) factor -> . TRUE
    (88) factor -> . FALSE
    (89) factor -> . LPAREN expression RPAREN
    (90) factor -> . NOT factor
    (91) factor -> . function_call
    (92) string_access -> . ID LBRACKET expression RBRACKET
    (95) function_call -> . ID LPAREN expression_list RPAREN
    (96) function_call -> . ID LPAREN RPAREN
    (97) function_call -> . LENGTH LPAREN expression RPAREN

    ID              shift and go to state 63
    INTEGER         shift and go to state 61
    REAL            shift and go to state 66
    STRING          shift and go to state 67
    TRUE            shift and go to state 68
    FALSE           shift and go to state 69
    LPAREN          shift and go to state 70
    NOT             shift and go to state 71
    LENGTH          shift and go to state 44

    expression                     shift and go to state 73
    simple_expression              shift and go to state 59
    variable                       shift and go to state 60
    term                           shift and go to state 62
    factor                         shift and go to state 64
    string_access                  shift and go to state 65
    function_call                  shift and go to state 72

state 39

    (45) for_statement -> FOR . ID ASSIGN expression TO expression DO statement
    (46) for_statement -> FOR . ID ASSIGN expression DOWNTO expression DO statement

    ID              shift and go to state 74


state 40

    (49) procedure_call_statement -> WRITELN . LPAREN expression_list RPAREN
    (50) procedure_call_statement -> WRITELN . LPAREN RPAREN

    LPAREN          shift and go to state 75


state 41

    (51) procedure_call_statement -> READLN . LPAREN variable RPAREN
    (52) procedure_call_statement -> READLN . LPAREN RPAREN

    LPAREN          shift and go to state 76


state 42

    (53) function_call_statement -> function_call .

    END             reduce using rule 53 (function_call_statement -> function_call .)
    SEMICOLON       reduce using rule 53 (function_call_statement -> function_call .)
    ELSE            reduce using rule 53 (function_call_statement -> function_call .)


state 43

    (98) halt_statement -> HALT .

    END             reduce using rule 98 (halt_statement -> HALT .)
    SEMICOLON       reduce using rule 98 (halt_statement -> HALT .)
    ELSE            reduce using rule 98 (halt_statement -> HALT .)


state 44

    (97) function_call -> LENGTH . LPAREN expression RPAREN

    LPAREN          shift and go to state 77


state 45

    (14) var_declarations -> var_declarations var_declaration .

    ID              reduce using rule 14 (var_declarations -> var_declarations var_declaration .)
    VAR             reduce using rule 14 (var_declarations -> var_declarations var_declaration .)
    FUNCTION        reduce using rule 14 (var_declarations -> var_declarations var_declaration .)
    PROCEDURE       reduce using rule 14 (var_declarations -> var_declarations var_declaration .)
    BEGIN           reduce using rule 14 (var_declarations -> var_declarations var_declaration .)


state 46

    (16) var_declaration -> id_list COLON . type_spec SEMICOLON
    (19) type_spec -> . INTEGER_TYPE
    (20) type_spec -> . REAL_TYPE
    (21) type_spec -> . BOOLEAN
    (22) type_spec -> . STRING_TYPE
    (23) type_spec -> . CHAR_TYPE
    (24) type_spec -> . array_type
    (25) array_type -> . ARRAY LBRACKET INTEGER PERIOD PERIOD INTEGER RBRACKET OF type_spec

    INTEGER_TYPE    shift and go to state 79
    REAL_TYPE       shift and go to state 80
    BOOLEAN         shift and go to state 81
    STRING_TYPE     shift and go to state 82
    CHAR_TYPE       shift and go to state 83
    ARRAY           shift and go to state 85

    type_spec                      shift and go to state 78
    array_type                     shift and go to state 84

state 47

    (17) id_list -> id_list COMMA . ID

    ID              shift and go to state 86


state 48

    (10) function_declaration -> FUNCTION ID LPAREN . param_list RPAREN COLON type_spec SEMICOLON function_block SEMICOLON
    (56) param_list -> . param_list SEMICOLON param
    (57) param_list -> . param
    (58) param_list -> . empty
    (59) param -> . id_list COLON type_spec
    (60) param -> . VAR id_list COLON type_spec
    (99) empty -> .
    (17) id_list -> . id_list COMMA ID
    (18) id_list -> . ID

    VAR             shift and go to state 91
    RPAREN          reduce using rule 99 (empty -> .)
    SEMICOLON       reduce using rule 99 (empty -> .)
    ID              shift and go to state 21

    param_list                     shift and go to state 87
    param                          shift and go to state 88
    empty                          shift and go to state 89
    id_list                        shift and go to state 90

state 49

    (11) function_declaration -> FUNCTION ID COLON . type_spec SEMICOLON function_block SEMICOLON
    (19) type_spec -> . INTEGER_TYPE
    (20) type_spec -> . REAL_TYPE
    (21) type_spec -> . BOOLEAN
    (22) type_spec -> . STRING_TYPE
    (23) type_spec -> . CHAR_TYPE
    (24) type_spec -> . array_type
    (25) array_type -> . ARRAY LBRACKET INTEGER PERIOD PERIOD INTEGER RBRACKET OF type_spec

    INTEGER_TYPE    shift and go to state 79
    REAL_TYPE       shift and go to state 80
    BOOLEAN         shift and go to state 81
    STRING_TYPE     shift and go to state 82
    CHAR_TYPE       shift and go to state 83
    ARRAY           shift and go to state 85

    type_spec                      shift and go to state 92
    array_type                     shift and go to state 84

state 50

    (12) procedure_declaration -> PROCEDURE ID LPAREN . param_list RPAREN SEMICOLON function_block SEMICOLON
    (56) param_list -> . param_list SEMICOLON param
    (57) param_list -> . param
    (58) param_list -> . empty
    (59) param -> . id_list COLON type_spec
    (60) param -> . VAR id_list COLON type_spec
    (99) empty -> .
    (17) id_list -> . id_list COMMA ID
    (18) id_list -> . ID

    VAR             shift and go to state 91
    RPAREN          reduce using rule 99 (empty -> .)
    SEMICOLON       reduce using rule 99 (empty -> .)
    ID              shift and go to state 21

    param_list                     shift and go to state 93
    param                          shift and go to state 88
    empty                          shift and go to state 89
    id_list                        shift and go to state 90

state 51

    (13) procedure_declaration -> PROCEDURE ID SEMICOLON . function_block SEMICOLON
    (8) function_block -> . declarations compound_statement
    (9) function_block -> . compound_statement
    (3) declarations -> . declaration declarations
    (4) declarations -> . empty
    (26) compound_statement -> . BEGIN statement_list END
    (5) declaration -> . VAR var_declarations
    (6) declaration -> . function_declaration
    (7) declaration -> . procedure_declaration
    (99) empty -> .
    (10) function_declaration -> . FUNCTION ID LPAREN param_list RPAREN COLON type_spec SEMICOLON function_block SEMICOLON
    (11) function_declaration -> . FUNCTION ID COLON type_spec SEMICOLON function_block SEMICOLON
    (12) procedure_declaration -> . PROCEDURE ID LPAREN param_list RPAREN SEMICOLON function_block SEMICOLON
    (13) procedure_declaration -> . PROCEDURE ID SEMICOLON function_block SEMICOLON

  ! shift/reduce conflict for BEGIN resolved as shift
    BEGIN           shift and go to state 16
    VAR             shift and go to state 9
    FUNCTION        shift and go to state 12
    PROCEDURE       shift and go to state 13

  ! BEGIN           [ reduce using rule 99 (empty -> .) ]

    function_block                 shift and go to state 94
    declarations                   shift and go to state 95
    compound_statement             shift and go to state 96
    declaration                    shift and go to state 7
    empty                          shift and go to state 8
    function_declaration           shift and go to state 10
    procedure_declaration          shift and go to state 11

state 52

    (26) compound_statement -> BEGIN statement_list END .

    PERIOD          reduce using rule 26 (compound_statement -> BEGIN statement_list END .)
    END             reduce using rule 26 (compound_statement -> BEGIN statement_list END .)
    SEMICOLON       reduce using rule 26 (compound_statement -> BEGIN statement_list END .)
    ELSE            reduce using rule 26 (compound_statement -> BEGIN statement_list END .)


state 53

    (27) statement_list -> statement_list SEMICOLON . statement
    (29) statement -> . compound_statement
    (30) statement -> . assignment_statement
    (31) statement -> . if_statement
    (32) statement -> . while_statement
    (33) statement -> . for_statement
    (34) statement -> . procedure_call_statement
    (35) statement -> . function_call_statement
    (36) statement -> . halt_statement
    (37) statement -> . empty
    (26) compound_statement -> . BEGIN statement_list END
    (38) assignment_statement -> . variable ASSIGN expression
    (39) assignment_statement -> . ID ASSIGN expression
    (42) if_statement -> . IF expression THEN statement
    (43) if_statement -> . IF expression THEN statement ELSE statement
    (44) while_statement -> . WHILE expression DO statement
    (45) for_statement -> . FOR ID ASSIGN expression TO expression DO statement
    (46) for_statement -> . FOR ID ASSIGN expression DOWNTO expression DO statement
    (47) procedure_call_statement -> . ID LPAREN expression_list RPAREN
    (48) procedure_call_statement -> . ID LPAREN RPAREN
    (49) procedure_call_statement -> . WRITELN LPAREN expression_list RPAREN
    (50) procedure_call_statement -> . WRITELN LPAREN RPAREN
    (51) procedure_call_statement -> . READLN LPAREN variable RPAREN
    (52) procedure_call_statement -> . READLN LPAREN RPAREN
    (53) function_call_statement -> . function_call
    (98) halt_statement -> . HALT
    (99) empty -> .
    (40) variable -> . ID
    (41) variable -> . ID LBRACKET expression RBRACKET
    (95) function_call -> . ID LPAREN expression_list RPAREN
    (96) function_call -> . ID LPAREN RPAREN
    (97) function_call -> . LENGTH LPAREN expression RPAREN

    BEGIN           shift and go to state 16
    ID              shift and go to state 36
    IF              shift and go to state 37
    WHILE           shift and go to state 38
    FOR             shift and go to state 39
    WRITELN         shift and go to state 40
    READLN          shift and go to state 41
    HALT            shift and go to state 43
    END             reduce using rule 99 (empty -> .)
    SEMICOLON       reduce using rule 99 (empty -> .)
    LENGTH          shift and go to state 44

    statement                      shift and go to state 97
    compound_statement             shift and go to state 26
    assignment_statement           shift and go to state 27
    if_statement                   shift and go to state 28
    while_statement                shift and go to state 29
    for_statement                  shift and go to state 30
    procedure_call_statement       shift and go to state 31
    function_call_statement        shift and go to state 32
    halt_statement                 shift and go to state 33
    empty                          shift and go to state 34
    variable                       shift and go to state 35
    function_call                  shift and go to state 42

state 54

    (38) assignment_statement -> variable ASSIGN . expression
    (61) expression -> . simple_expression
    (62) expression -> . simple_expression relop simple_expression
    (93) expression -> . variable COLON INTEGER
    (94) expression -> . variable COLON INTEGER COLON INTEGER
    (70) simple_expression -> . term
    (71) simple_expression -> . simple_expression addop term
    (40) variable -> . ID
    (41) variable -> . ID LBRACKET expression RBRACKET
    (75) term -> . factor
    (76) term -> . term mulop factor
    (82) factor -> . string_access
    (83) factor -> . variable
    (84) factor -> . INTEGER
    (85) factor -> . REAL
    (86) factor -> . STRING
    (87) factor -> . TRUE
    (88) factor -> . FALSE
    (89) factor -> . LPAREN expression RPAREN
    (90) factor -> . NOT factor
    (91) factor -> . function_call
    (92) string_access -> . ID LBRACKET expression RBRACKET
    (95) function_call -> . ID LPAREN expression_list RPAREN
    (96) function_call -> . ID LPAREN RPAREN
    (97) function_call -> . LENGTH LPAREN expression RPAREN

    ID              shift and go to state 63
    INTEGER         shift and go to state 61
    REAL            shift and go to state 66
    STRING          shift and go to state 67
    TRUE            shift and go to state 68
    FALSE           shift and go to state 69
    LPAREN          shift and go to state 70
    NOT             shift and go to state 71
    LENGTH          shift and go to state 44

    variable                       shift and go to state 60
    expression                     shift and go to state 98
    simple_expression              shift and go to state 59
    term                           shift and go to state 62
    factor                         shift and go to state 64
    string_access                  shift and go to state 65
    function_call                  shift and go to state 72

state 55

    (39) assignment_statement -> ID ASSIGN . expression
    (61) expression -> . simple_expression
    (62) expression -> . simple_expression relop simple_expression
    (93) expression -> . variable COLON INTEGER
    (94) expression -> . variable COLON INTEGER COLON INTEGER
    (70) simple_expression -> . term
    (71) simple_expression -> . simple_expression addop term
    (40) variable -> . ID
    (41) variable -> . ID LBRACKET expression RBRACKET
    (75) term -> . factor
    (76) term -> . term mulop factor
    (82) factor -> . string_access
    (83) factor -> . variable
    (84) factor -> . INTEGER
    (85) factor -> . REAL
    (86) factor -> . STRING
    (87) factor -> . TRUE
    (88) factor -> . FALSE
    (89) factor -> . LPAREN expression RPAREN
    (90) factor -> . NOT factor
    (91) factor -> . function_call
    (92) string_access -> . ID LBRACKET expression RBRACKET
    (95) function_call -> . ID LPAREN expression_list RPAREN
    (96) function_call -> . ID LPAREN RPAREN
    (97) function_call -> . LENGTH LPAREN expression RPAREN

    ID              shift and go to state 63
    INTEGER         shift and go to state 61
    REAL            shift and go to state 66
    STRING          shift and go to state 67
    TRUE            shift and go to state 68
    FALSE           shift and go to state 69
    LPAREN          shift and go to state 70
    NOT             shift and go to state 71
    LENGTH          shift and go to state 44

    expression                     shift and go to state 99
    simple_expression              shift and go to state 59
    variable                       shift and go to state 60
    term                           shift and go to state 62
    factor                         shift and go to state 64
    string_access                  shift and go to state 65
    function_call                  shift and go to state 72

state 56

    (47) procedure_call_statement -> ID LPAREN . expression_list RPAREN
    (48) procedure_call_statement -> ID LPAREN . RPAREN
    (95) function_call -> ID LPAREN . expression_list RPAREN
    (96) function_call -> ID LPAREN . RPAREN
    (54) expression_list -> . expression_list COMMA expression
    (55) expression_list -> . expression
    (61) expression -> . simple_expression
    (62) expression -> . simple_expression relop simple_expression
    (93) expression -> . variable COLON INTEGER
    (94) expression -> . variable COLON INTEGER COLON INTEGER
    (70) simple_expression -> . term
    (71) simple_expression -> . simple_expression addop term
    (40) variable -> . ID
    (41) variable -> . ID LBRACKET expression RBRACKET
    (75) term -> . factor
    (76) term -> . term mulop factor
    (82) factor -> . string_access
    (83) factor -> . variable
    (84) factor -> . INTEGER
    (85) factor -> . REAL
    (86) factor -> . STRING
    (87) factor -> . TRUE
    (88) factor -> . FALSE
    (89) factor -> . LPAREN expression RPAREN
    (90) factor -> . NOT factor
    (91) factor -> . function_call
    (92) string_access -> . ID LBRACKET expression RBRACKET
    (95) function_call -> . ID LPAREN expression_list RPAREN
    (96) function_call -> . ID LPAREN RPAREN
    (97) function_call -> . LENGTH LPAREN expression RPAREN

    RPAREN          shift and go to state 101
    ID              shift and go to state 63
    INTEGER         shift and go to state 61
    REAL            shift and go to state 66
    STRING          shift and go to state 67
    TRUE            shift and go to state 68
    FALSE           shift and go to state 69
    LPAREN          shift and go to state 70
    NOT             shift and go to state 71
    LENGTH          shift and go to state 44

    expression_list                shift and go to state 100
    expression                     shift and go to state 102
    simple_expression              shift and go to state 59
    variable                       shift and go to state 60
    term                           shift and go to state 62
    factor                         shift and go to state 64
    string_access                  shift and go to state 65
    function_call                  shift and go to state 72

state 57

    (41) variable -> ID LBRACKET . expression RBRACKET
    (61) expression -> . simple_expression
    (62) expression -> . simple_expression relop simple_expression
    (93) expression -> . variable COLON INTEGER
    (94) expression -> . variable COLON INTEGER COLON INTEGER
    (70) simple_expression -> . term
    (71) simple_expression -> . simple_expression addop term
    (40) variable -> . ID
    (41) variable -> . ID LBRACKET expression RBRACKET
    (75) term -> . factor
    (76) term -> . term mulop factor
    (82) factor -> . string_access
    (83) factor -> . variable
    (84) factor -> . INTEGER
    (85) factor -> . REAL
    (86) factor -> . STRING
    (87) factor -> . TRUE
    (88) factor -> . FALSE
    (89) factor -> . LPAREN expression RPAREN
    (90) factor -> . NOT factor
    (91) factor -> . function_call
    (92) string_access -> . ID LBRACKET expression RBRACKET
    (95) function_call -> . ID LPAREN expression_list RPAREN
    (96) function_call -> . ID LPAREN RPAREN
    (97) function_call -> . LENGTH LPAREN expression RPAREN

    ID              shift and go to state 63
    INTEGER         shift and go to state 61
    REAL            shift and go to state 66
    STRING          shift and go to state 67
    TRUE            shift and go to state 68
    FALSE           shift and go to state 69
    LPAREN          shift and go to state 70
    NOT             shift and go to state 71
    LENGTH          shift and go to state 44

    expression                     shift and go to state 103
    simple_expression              shift and go to state 59
    variable                       shift and go to state 60
    term                           shift and go to state 62
    factor                         shift and go to state 64
    string_access                  shift and go to state 65
    function_call                  shift and go to state 72

state 58

    (42) if_statement -> IF expression . THEN statement
    (43) if_statement -> IF expression . THEN statement ELSE statement

    THEN            shift and go to state 104


state 59

    (61) expression -> simple_expression .
    (62) expression -> simple_expression . relop simple_expression
    (71) simple_expression -> simple_expression . addop term
    (63) relop -> . EQ
    (64) relop -> . NEQ
    (65) relop -> . LT
    (66) relop -> . LE
    (67) relop -> . GT
    (68) relop -> . GE
    (69) relop -> . IN
    (72) addop -> . PLUS
    (73) addop -> . MINUS
    (74) addop -> . OR

    THEN            reduce using rule 61 (expression -> simple_expression .)
    DO              reduce using rule 61 (expression -> simple_expression .)
    END             reduce using rule 61 (expression -> simple_expression .)
    SEMICOLON       reduce using rule 61 (expression -> simple_expression .)
    ELSE            reduce using rule 61 (expression -> simple_expression .)
    RPAREN          reduce using rule 61 (expression -> simple_expression .)
    COMMA           reduce using rule 61 (expression -> simple_expression .)
    RBRACKET        reduce using rule 61 (expression -> simple_expression .)
    TO              reduce using rule 61 (expression -> simple_expression .)
    DOWNTO          reduce using rule 61 (expression -> simple_expression .)
    EQ              shift and go to state 107
    NEQ             shift and go to state 108
    LT              shift and go to state 109
    LE              shift and go to state 110
    GT              shift and go to state 111
    GE              shift and go to state 112
    IN              shift and go to state 113
    PLUS            shift and go to state 114
    MINUS           shift and go to state 115
    OR              shift and go to state 116

    relop                          shift and go to state 105
    addop                          shift and go to state 106

state 60

    (93) expression -> variable . COLON INTEGER
    (94) expression -> variable . COLON INTEGER COLON INTEGER
    (83) factor -> variable .

    COLON           shift and go to state 117
    TIMES           reduce using rule 83 (factor -> variable .)
    DIVIDE          reduce using rule 83 (factor -> variable .)
    DIV             reduce using rule 83 (factor -> variable .)
    MOD             reduce using rule 83 (factor -> variable .)
    AND             reduce using rule 83 (factor -> variable .)
    EQ              reduce using rule 83 (factor -> variable .)
    NEQ             reduce using rule 83 (factor -> variable .)
    LT              reduce using rule 83 (factor -> variable .)
    LE              reduce using rule 83 (factor -> variable .)
    GT              reduce using rule 83 (factor -> variable .)
    GE              reduce using rule 83 (factor -> variable .)
    IN              reduce using rule 83 (factor -> variable .)
    PLUS            reduce using rule 83 (factor -> variable .)
    MINUS           reduce using rule 83 (factor -> variable .)
    OR              reduce using rule 83 (factor -> variable .)
    THEN            reduce using rule 83 (factor -> variable .)
    DO              reduce using rule 83 (factor -> variable .)
    END             reduce using rule 83 (factor -> variable .)
    SEMICOLON       reduce using rule 83 (factor -> variable .)
    ELSE            reduce using rule 83 (factor -> variable .)
    RPAREN          reduce using rule 83 (factor -> variable .)
    COMMA           reduce using rule 83 (factor -> variable .)
    RBRACKET        reduce using rule 83 (factor -> variable .)
    TO              reduce using rule 83 (factor -> variable .)
    DOWNTO          reduce using rule 83 (factor -> variable .)


state 61

    (84) factor -> INTEGER .

    TIMES           reduce using rule 84 (factor -> INTEGER .)
    DIVIDE          reduce using rule 84 (factor -> INTEGER .)
    DIV             reduce using rule 84 (factor -> INTEGER .)
    MOD             reduce using rule 84 (factor -> INTEGER .)
    AND             reduce using rule 84 (factor -> INTEGER .)
    EQ              reduce using rule 84 (factor -> INTEGER .)
    NEQ             reduce using rule 84 (factor -> INTEGER .)
    LT              reduce using rule 84 (factor -> INTEGER .)
    LE              reduce using rule 84 (factor -> INTEGER .)
    GT              reduce using rule 84 (factor -> INTEGER .)
    GE              reduce using rule 84 (factor -> INTEGER .)
    IN              reduce using rule 84 (factor -> INTEGER .)
    PLUS            reduce using rule 84 (factor -> INTEGER .)
    MINUS           reduce using rule 84 (factor -> INTEGER .)
    OR              reduce using rule 84 (factor -> INTEGER .)
    THEN            reduce using rule 84 (factor -> INTEGER .)
    DO              reduce using rule 84 (factor -> INTEGER .)
    END             reduce using rule 84 (factor -> INTEGER .)
    SEMICOLON       reduce using rule 84 (factor -> INTEGER .)
    ELSE            reduce using rule 84 (factor -> INTEGER .)
    RPAREN          reduce using rule 84 (factor -> INTEGER .)
    COMMA           reduce using rule 84 (factor -> INTEGER .)
    RBRACKET        reduce using rule 84 (factor -> INTEGER .)
    TO              reduce using rule 84 (factor -> INTEGER .)
    DOWNTO          reduce using rule 84 (factor -> INTEGER .)


state 62

    (70) simple_expression -> term .
    (76) term -> term . mulop factor
    (77) mulop -> . TIMES
    (78) mulop -> . DIVIDE
    (79) mulop -> . DIV
    (80) mulop -> . MOD
    (81) mulop -> . AND

    EQ              reduce using rule 70 (simple_expression -> term .)
    NEQ             reduce using rule 70 (simple_expression -> term .)
    LT              reduce using rule 70 (simple_expression -> term .)
    LE              reduce using rule 70 (simple_expression -> term .)
    GT              reduce using rule 70 (simple_expression -> term .)
    GE              reduce using rule 70 (simple_expression -> term .)
    IN              reduce using rule 70 (simple_expression -> term .)
    PLUS            reduce using rule 70 (simple_expression -> term .)
    MINUS           reduce using rule 70 (simple_expression -> term .)
    OR              reduce using rule 70 (simple_expression -> term .)
    THEN            reduce using rule 70 (simple_expression -> term .)
    DO              reduce using rule 70 (simple_expression -> term .)
    END             reduce using rule 70 (simple_expression -> term .)
    SEMICOLON       reduce using rule 70 (simple_expression -> term .)
    ELSE            reduce using rule 70 (simple_expression -> term .)
    RPAREN          reduce using rule 70 (simple_expression -> term .)
    COMMA           reduce using rule 70 (simple_expression -> term .)
    RBRACKET        reduce using rule 70 (simple_expression -> term .)
    TO              reduce using rule 70 (simple_expression -> term .)
    DOWNTO          reduce using rule 70 (simple_expression -> term .)
    TIMES           shift and go to state 119
    DIVIDE          shift and go to state 120
    DIV             shift and go to state 121
    MOD             shift and go to state 122
    AND             shift and go to state 123

    mulop                          shift and go to state 118

state 63

    (40) variable -> ID .
    (41) variable -> ID . LBRACKET expression RBRACKET
    (92) string_access -> ID . LBRACKET expression RBRACKET
    (95) function_call -> ID . LPAREN expression_list RPAREN
    (96) function_call -> ID . LPAREN RPAREN

    COLON           reduce using rule 40 (variable -> ID .)
    TIMES           reduce using rule 40 (variable -> ID .)
    DIVIDE          reduce using rule 40 (variable -> ID .)
    DIV             reduce using rule 40 (variable -> ID .)
    MOD             reduce using rule 40 (variable -> ID .)
    AND             reduce using rule 40 (variable -> ID .)
    EQ              reduce using rule 40 (variable -> ID .)
    NEQ             reduce using rule 40 (variable -> ID .)
    LT              reduce using rule 40 (variable -> ID .)
    LE              reduce using rule 40 (variable -> ID .)
    GT              reduce using rule 40 (variable -> ID .)
    GE              reduce using rule 40 (variable -> ID .)
    IN              reduce using rule 40 (variable -> ID .)
    PLUS            reduce using rule 40 (variable -> ID .)
    MINUS           reduce using rule 40 (variable -> ID .)
    OR              reduce using rule 40 (variable -> ID .)
    THEN            reduce using rule 40 (variable -> ID .)
    DO              reduce using rule 40 (variable -> ID .)
    END             reduce using rule 40 (variable -> ID .)
    SEMICOLON       reduce using rule 40 (variable -> ID .)
    ELSE            reduce using rule 40 (variable -> ID .)
    RPAREN          reduce using rule 40 (variable -> ID .)
    COMMA           reduce using rule 40 (variable -> ID .)
    RBRACKET        reduce using rule 40 (variable -> ID .)
    TO              reduce using rule 40 (variable -> ID .)
    DOWNTO          reduce using rule 40 (variable -> ID .)
    LBRACKET        shift and go to state 124
    LPAREN          shift and go to state 125


state 64

    (75) term -> factor .

    TIMES           reduce using rule 75 (term -> factor .)
    DIVIDE          reduce using rule 75 (term -> factor .)
    DIV             reduce using rule 75 (term -> factor .)
    MOD             reduce using rule 75 (term -> factor .)
    AND             reduce using rule 75 (term -> factor .)
    EQ              reduce using rule 75 (term -> factor .)
    NEQ             reduce using rule 75 (term -> factor .)
    LT              reduce using rule 75 (term -> factor .)
    LE              reduce using rule 75 (term -> factor .)
    GT              reduce using rule 75 (term -> factor .)
    GE              reduce using rule 75 (term -> factor .)
    IN              reduce using rule 75 (term -> factor .)
    PLUS            reduce using rule 75 (term -> factor .)
    MINUS           reduce using rule 75 (term -> factor .)
    OR              reduce using rule 75 (term -> factor .)
    THEN            reduce using rule 75 (term -> factor .)
    DO              reduce using rule 75 (term -> factor .)
    END             reduce using rule 75 (term -> factor .)
    SEMICOLON       reduce using rule 75 (term -> factor .)
    ELSE            reduce using rule 75 (term -> factor .)
    RPAREN          reduce using rule 75 (term -> factor .)
    COMMA           reduce using rule 75 (term -> factor .)
    RBRACKET        reduce using rule 75 (term -> factor .)
    TO              reduce using rule 75 (term -> factor .)
    DOWNTO          reduce using rule 75 (term -> factor .)


state 65

    (82) factor -> string_access .

    TIMES           reduce using rule 82 (factor -> string_access .)
    DIVIDE          reduce using rule 82 (factor -> string_access .)
    DIV             reduce using rule 82 (factor -> string_access .)
    MOD             reduce using rule 82 (factor -> string_access .)
    AND             reduce using rule 82 (factor -> string_access .)
    EQ              reduce using rule 82 (factor -> string_access .)
    NEQ             reduce using rule 82 (factor -> string_access .)
    LT              reduce using rule 82 (factor -> string_access .)
    LE              reduce using rule 82 (factor -> string_access .)
    GT              reduce using rule 82 (factor -> string_access .)
    GE              reduce using rule 82 (factor -> string_access .)
    IN              reduce using rule 82 (factor -> string_access .)
    PLUS            reduce using rule 82 (factor -> string_access .)
    MINUS           reduce using rule 82 (factor -> string_access .)
    OR              reduce using rule 82 (factor -> string_access .)
    THEN            reduce using rule 82 (factor -> string_access .)
    DO              reduce using rule 82 (factor -> string_access .)
    END             reduce using rule 82 (factor -> string_access .)
    SEMICOLON       reduce using rule 82 (factor -> string_access .)
    ELSE            reduce using rule 82 (factor -> string_access .)
    RPAREN          reduce using rule 82 (factor -> string_access .)
    COMMA           reduce using rule 82 (factor -> string_access .)
    RBRACKET        reduce using rule 82 (factor -> string_access .)
    TO              reduce using rule 82 (factor -> string_access .)
    DOWNTO          reduce using rule 82 (factor -> string_access .)


state 66

    (85) factor -> REAL .

    TIMES           reduce using rule 85 (factor -> REAL .)
    DIVIDE          reduce using rule 85 (factor -> REAL .)
    DIV             reduce using rule 85 (factor -> REAL .)
    MOD             reduce using rule 85 (factor -> REAL .)
    AND             reduce using rule 85 (factor -> REAL .)
    EQ              reduce using rule 85 (factor -> REAL .)
    NEQ             reduce using rule 85 (factor -> REAL .)
    LT              reduce using rule 85 (factor -> REAL .)
    LE              reduce using rule 85 (factor -> REAL .)
    GT              reduce using rule 85 (factor -> REAL .)
    GE              reduce using rule 85 (factor -> REAL .)
    IN              reduce using rule 85 (factor -> REAL .)
    PLUS            reduce using rule 85 (factor -> REAL .)
    MINUS           reduce using rule 85 (factor -> REAL .)
    OR              reduce using rule 85 (factor -> REAL .)
    THEN            reduce using rule 85 (factor -> REAL .)
    DO              reduce using rule 85 (factor -> REAL .)
    END             reduce using rule 85 (factor -> REAL .)
    SEMICOLON       reduce using rule 85 (factor -> REAL .)
    ELSE            reduce using rule 85 (factor -> REAL .)
    RPAREN          reduce using rule 85 (factor -> REAL .)
    COMMA           reduce using rule 85 (factor -> REAL .)
    RBRACKET        reduce using rule 85 (factor -> REAL .)
    TO              reduce using rule 85 (factor -> REAL .)
    DOWNTO          reduce using rule 85 (factor -> REAL .)


state 67

    (86) factor -> STRING .

    TIMES           reduce using rule 86 (factor -> STRING .)
    DIVIDE          reduce using rule 86 (factor -> STRING .)
    DIV             reduce using rule 86 (factor -> STRING .)
    MOD             reduce using rule 86 (factor -> STRING .)
    AND             reduce using rule 86 (factor -> STRING .)
    EQ              reduce using rule 86 (factor -> STRING .)
    NEQ             reduce using rule 86 (factor -> STRING .)
    LT              reduce using rule 86 (factor -> STRING .)
    LE              reduce using rule 86 (factor -> STRING .)
    GT              reduce using rule 86 (factor -> STRING .)
    GE              reduce using rule 86 (factor -> STRING .)
    IN              reduce using rule 86 (factor -> STRING .)
    PLUS            reduce using rule 86 (factor -> STRING .)
    MINUS           reduce using rule 86 (factor -> STRING .)
    OR              reduce using rule 86 (factor -> STRING .)
    THEN            reduce using rule 86 (factor -> STRING .)
    DO              reduce using rule 86 (factor -> STRING .)
    END             reduce using rule 86 (factor -> STRING .)
    SEMICOLON       reduce using rule 86 (factor -> STRING .)
    ELSE            reduce using rule 86 (factor -> STRING .)
    RPAREN          reduce using rule 86 (factor -> STRING .)
    COMMA           reduce using rule 86 (factor -> STRING .)
    RBRACKET        reduce using rule 86 (factor -> STRING .)
    TO              reduce using rule 86 (factor -> STRING .)
    DOWNTO          reduce using rule 86 (factor -> STRING .)


state 68

    (87) factor -> TRUE .

    TIMES           reduce using rule 87 (factor -> TRUE .)
    DIVIDE          reduce using rule 87 (factor -> TRUE .)
    DIV             reduce using rule 87 (factor -> TRUE .)
    MOD             reduce using rule 87 (factor -> TRUE .)
    AND             reduce using rule 87 (factor -> TRUE .)
    EQ              reduce using rule 87 (factor -> TRUE .)
    NEQ             reduce using rule 87 (factor -> TRUE .)
    LT              reduce using rule 87 (factor -> TRUE .)
    LE              reduce using rule 87 (factor -> TRUE .)
    GT              reduce using rule 87 (factor -> TRUE .)
    GE              reduce using rule 87 (factor -> TRUE .)
    IN              reduce using rule 87 (factor -> TRUE .)
    PLUS            reduce using rule 87 (factor -> TRUE .)
    MINUS           reduce using rule 87 (factor -> TRUE .)
    OR              reduce using rule 87 (factor -> TRUE .)
    THEN            reduce using rule 87 (factor -> TRUE .)
    DO              reduce using rule 87 (factor -> TRUE .)
    END             reduce using rule 87 (factor -> TRUE .)
    SEMICOLON       reduce using rule 87 (factor -> TRUE .)
    ELSE            reduce using rule 87 (factor -> TRUE .)
    RPAREN          reduce using rule 87 (factor -> TRUE .)
    COMMA           reduce using rule 87 (factor -> TRUE .)
    RBRACKET        reduce using rule 87 (factor -> TRUE .)
    TO              reduce using rule 87 (factor -> TRUE .)
    DOWNTO          reduce using rule 87 (factor -> TRUE .)


state 69

    (88) factor -> FALSE .

    TIMES           reduce using rule 88 (factor -> FALSE .)
    DIVIDE          reduce using rule 88 (factor -> FALSE .)
    DIV             reduce using rule 88 (factor -> FALSE .)
    MOD             reduce using rule 88 (factor -> FALSE .)
    AND             reduce using rule 88 (factor -> FALSE .)
    EQ              reduce using rule 88 (factor -> FALSE .)
    NEQ             reduce using rule 88 (factor -> FALSE .)
    LT              reduce using rule 88 (factor -> FALSE .)
    LE              reduce using rule 88 (factor -> FALSE .)
    GT              reduce using rule 88 (factor -> FALSE .)
    GE              reduce using rule 88 (factor -> FALSE .)
    IN              reduce using rule 88 (factor -> FALSE .)
    PLUS            reduce using rule 88 (factor -> FALSE .)
    MINUS           reduce using rule 88 (factor -> FALSE .)
    OR              reduce using rule 88 (factor -> FALSE .)
    THEN            reduce using rule 88 (factor -> FALSE .)
    DO              reduce using rule 88 (factor -> FALSE .)
    END             reduce using rule 88 (factor -> FALSE .)
    SEMICOLON       reduce using rule 88 (factor -> FALSE .)
    ELSE            reduce using rule 88 (factor -> FALSE .)
    RPAREN          reduce using rule 88 (factor -> FALSE .)
    COMMA           reduce using rule 88 (factor -> FALSE .)
    RBRACKET        reduce using rule 88 (factor -> FALSE .)
    TO              reduce using rule 88 (factor -> FALSE .)
    DOWNTO          reduce using rule 88 (factor -> FALSE .)


state 70

    (89) factor -> LPAREN . expression RPAREN
    (61) expression -> . simple_expression
    (62) expression -> . simple_expression relop simple_expression
    (93) expression -> . variable COLON INTEGER
    (94) expression -> . variable COLON INTEGER COLON INTEGER
    (70) simple_expression -> . term
    (71) simple_expression -> . simple_expression addop term
    (40) variable -> . ID
    (41) variable -> . ID LBRACKET expression RBRACKET
    (75) term -> . factor
    (76) term -> . term mulop factor
    (82) factor -> . string_access
    (83) factor -> . variable
    (84) factor -> . INTEGER
    (85) factor -> . REAL
    (86) factor -> . STRING
    (87) factor -> . TRUE
    (88) factor -> . FALSE
    (89) factor -> . LPAREN expression RPAREN
    (90) factor -> . NOT factor
    (91) factor -> . function_call
    (92) string_access -> . ID LBRACKET expression RBRACKET
    (95) function_call -> . ID LPAREN expression_list RPAREN
    (96) function_call -> . ID LPAREN RPAREN
    (97) function_call -> . LENGTH LPAREN expression RPAREN

    ID              shift and go to state 63
    INTEGER         shift and go to state 61
    REAL            shift and go to state 66
    STRING          shift and go to state 67
    TRUE            shift and go to state 68
    FALSE           shift and go to state 69
    LPAREN          shift and go to state 70
    NOT             shift and go to state 71
    LENGTH          shift and go to state 44

    expression                     shift and go to state 126
    simple_expression              shift and go to state 59
    variable                       shift and go to state 60
    term                           shift and go to state 62
    factor                         shift and go to state 64
    string_access                  shift and go to state 65
    function_call                  shift and go to state 72

state 71

    (90) factor -> NOT . factor
    (82) factor -> . string_access
    (83) factor -> . variable
    (84) factor -> . INTEGER
    (85) factor -> . REAL
    (86) factor -> . STRING
    (87) factor -> . TRUE
    (88) factor -> . FALSE
    (89) factor -> . LPAREN expression RPAREN
    (90) factor -> . NOT factor
    (91) factor -> . function_call
    (92) string_access -> . ID LBRACKET expression RBRACKET
    (40) variable -> . ID
    (41) variable -> . ID LBRACKET expression RBRACKET
    (95) function_call -> . ID LPAREN expression_list RPAREN
    (96) function_call -> . ID LPAREN RPAREN
    (97) function_call -> . LENGTH LPAREN expression RPAREN

    INTEGER         shift and go to state 61
    REAL            shift and go to state 66
    STRING          shift and go to state 67
    TRUE            shift and go to state 68
    FALSE           shift and go to state 69
    LPAREN          shift and go to state 70
    NOT             shift and go to state 71
    ID              shift and go to state 129
    LENGTH          shift and go to state 44

    factor                         shift and go to state 127
    string_access                  shift and go to state 65
    variable                       shift and go to state 128
    function_call                  shift and go to state 72

state 72

    (91) factor -> function_call .

    TIMES           reduce using rule 91 (factor -> function_call .)
    DIVIDE          reduce using rule 91 (factor -> function_call .)
    DIV             reduce using rule 91 (factor -> function_call .)
    MOD             reduce using rule 91 (factor -> function_call .)
    AND             reduce using rule 91 (factor -> function_call .)
    EQ              reduce using rule 91 (factor -> function_call .)
    NEQ             reduce using rule 91 (factor -> function_call .)
    LT              reduce using rule 91 (factor -> function_call .)
    LE              reduce using rule 91 (factor -> function_call .)
    GT              reduce using rule 91 (factor -> function_call .)
    GE              reduce using rule 91 (factor -> function_call .)
    IN              reduce using rule 91 (factor -> function_call .)
    PLUS            reduce using rule 91 (factor -> function_call .)
    MINUS           reduce using rule 91 (factor -> function_call .)
    OR              reduce using rule 91 (factor -> function_call .)
    THEN            reduce using rule 91 (factor -> function_call .)
    DO              reduce using rule 91 (factor -> function_call .)
    END             reduce using rule 91 (factor -> function_call .)
    SEMICOLON       reduce using rule 91 (factor -> function_call .)
    ELSE            reduce using rule 91 (factor -> function_call .)
    RPAREN          reduce using rule 91 (factor -> function_call .)
    COMMA           reduce using rule 91 (factor -> function_call .)
    RBRACKET        reduce using rule 91 (factor -> function_call .)
    TO              reduce using rule 91 (factor -> function_call .)
    DOWNTO          reduce using rule 91 (factor -> function_call .)


state 73

    (44) while_statement -> WHILE expression . DO statement

    DO              shift and go to state 130


state 74

    (45) for_statement -> FOR ID . ASSIGN expression TO expression DO statement
    (46) for_statement -> FOR ID . ASSIGN expression DOWNTO expression DO statement

    ASSIGN          shift and go to state 131


state 75

    (49) procedure_call_statement -> WRITELN LPAREN . expression_list RPAREN
    (50) procedure_call_statement -> WRITELN LPAREN . RPAREN
    (54) expression_list -> . expression_list COMMA expression
    (55) expression_list -> . expression
    (61) expression -> . simple_expression
    (62) expression -> . simple_expression relop simple_expression
    (93) expression -> . variable COLON INTEGER
    (94) expression -> . variable COLON INTEGER COLON INTEGER
    (70) simple_expression -> . term
    (71) simple_expression -> . simple_expression addop term
    (40) variable -> . ID
    (41) variable -> . ID LBRACKET expression RBRACKET
    (75) term -> . factor
    (76) term -> . term mulop factor
    (82) factor -> . string_access
    (83) factor -> . variable
    (84) factor -> . INTEGER
    (85) factor -> . REAL
    (86) factor -> . STRING
    (87) factor -> . TRUE
    (88) factor -> . FALSE
    (89) factor -> . LPAREN expression RPAREN
    (90) factor -> . NOT factor
    (91) factor -> . function_call
    (92) string_access -> . ID LBRACKET expression RBRACKET
    (95) function_call -> . ID LPAREN expression_list RPAREN
    (96) function_call -> . ID LPAREN RPAREN
    (97) function_call -> . LENGTH LPAREN expression RPAREN

    RPAREN          shift and go to state 133
    ID              shift and go to state 63
    INTEGER         shift and go to state 61
    REAL            shift and go to state 66
    STRING          shift and go to state 67
    TRUE            shift and go to state 68
    FALSE           shift and go to state 69
    LPAREN          shift and go to state 70
    NOT             shift and go to state 71
    LENGTH          shift and go to state 44

    expression_list                shift and go to state 132
    expression                     shift and go to state 102
    simple_expression              shift and go to state 59
    variable                       shift and go to state 60
    term                           shift and go to state 62
    factor                         shift and go to state 64
    string_access                  shift and go to state 65
    function_call                  shift and go to state 72

state 76

    (51) procedure_call_statement -> READLN LPAREN . variable RPAREN
    (52) procedure_call_statement -> READLN LPAREN . RPAREN
    (40) variable -> . ID
    (41) variable -> . ID LBRACKET expression RBRACKET

    RPAREN          shift and go to state 135
    ID              shift and go to state 136

    variable                       shift and go to state 134

state 77

    (97) function_call -> LENGTH LPAREN . expression RPAREN
    (61) expression -> . simple_expression
    (62) expression -> . simple_expression relop simple_expression
    (93) expression -> . variable COLON INTEGER
    (94) expression -> . variable COLON INTEGER COLON INTEGER
    (70) simple_expression -> . term
    (71) simple_expression -> . simple_expression addop term
    (40) variable -> . ID
    (41) variable -> . ID LBRACKET expression RBRACKET
    (75) term -> . factor
    (76) term -> . term mulop factor
    (82) factor -> . string_access
    (83) factor -> . variable
    (84) factor -> . INTEGER
    (85) factor -> . REAL
    (86) factor -> . STRING
    (87) factor -> . TRUE
    (88) factor -> . FALSE
    (89) factor -> . LPAREN expression RPAREN
    (90) factor -> . NOT factor
    (91) factor -> . function_call
    (92) string_access -> . ID LBRACKET expression RBRACKET
    (95) function_call -> . ID LPAREN expression_list RPAREN
    (96) function_call -> . ID LPAREN RPAREN
    (97) function_call -> . LENGTH LPAREN expression RPAREN

    ID              shift and go to state 63
    INTEGER         shift and go to state 61
    REAL            shift and go to state 66
    STRING          shift and go to state 67
    TRUE            shift and go to state 68
    FALSE           shift and go to state 69
    LPAREN          shift and go to state 70
    NOT             shift and go to state 71
    LENGTH          shift and go to state 44

    expression                     shift and go to state 137
    simple_expression              shift and go to state 59
    variable                       shift and go to state 60
    term                           shift and go to state 62
    factor                         shift and go to state 64
    string_access                  shift and go to state 65
    function_call                  shift and go to state 72

state 78

    (16) var_declaration -> id_list COLON type_spec . SEMICOLON

    SEMICOLON       shift and go to state 138


state 79

    (19) type_spec -> INTEGER_TYPE .

    SEMICOLON       reduce using rule 19 (type_spec -> INTEGER_TYPE .)
    RPAREN          reduce using rule 19 (type_spec -> INTEGER_TYPE .)


state 80

    (20) type_spec -> REAL_TYPE .

    SEMICOLON       reduce using rule 20 (type_spec -> REAL_TYPE .)
    RPAREN          reduce using rule 20 (type_spec -> REAL_TYPE .)


state 81

    (21) type_spec -> BOOLEAN .

    SEMICOLON       reduce using rule 21 (type_spec -> BOOLEAN .)
    RPAREN          reduce using rule 21 (type_spec -> BOOLEAN .)


state 82

    (22) type_spec -> STRING_TYPE .

    SEMICOLON       reduce using rule 22 (type_spec -> STRING_TYPE .)
    RPAREN          reduce using rule 22 (type_spec -> STRING_TYPE .)


state 83

    (23) type_spec -> CHAR_TYPE .

    SEMICOLON       reduce using rule 23 (type_spec -> CHAR_TYPE .)
    RPAREN          reduce using rule 23 (type_spec -> CHAR_TYPE .)


state 84

    (24) type_spec -> array_type .

    SEMICOLON       reduce using rule 24 (type_spec -> array_type .)
    RPAREN          reduce using rule 24 (type_spec -> array_type .)


state 85

    (25) array_type -> ARRAY . LBRACKET INTEGER PERIOD PERIOD INTEGER RBRACKET OF type_spec

    LBRACKET        shift and go to state 139


state 86

    (17) id_list -> id_list COMMA ID .

    COLON           reduce using rule 17 (id_list -> id_list COMMA ID .)
    COMMA           reduce using rule 17 (id_list -> id_list COMMA ID .)


state 87

    (10) function_declaration -> FUNCTION ID LPAREN param_list . RPAREN COLON type_spec SEMICOLON function_block SEMICOLON
    (56) param_list -> param_list . SEMICOLON param

    RPAREN          shift and go to state 140
    SEMICOLON       shift and go to state 141


state 88

    (57) param_list -> param .

    RPAREN          reduce using rule 57 (param_list -> param .)
    SEMICOLON       reduce using rule 57 (param_list -> param .)


state 89

    (58) param_list -> empty .

    RPAREN          reduce using rule 58 (param_list -> empty .)
    SEMICOLON       reduce using rule 58 (param_list -> empty .)


state 90

    (59) param -> id_list . COLON type_spec
    (17) id_list -> id_list . COMMA ID

    COLON           shift and go to state 142
    COMMA           shift and go to state 47


state 91

    (60) param -> VAR . id_list COLON type_spec
    (17) id_list -> . id_list COMMA ID
    (18) id_list -> . ID

    ID              shift and go to state 21

    id_list                        shift and go to state 143

state 92

    (11) function_declaration -> FUNCTION ID COLON type_spec . SEMICOLON function_block SEMICOLON

    SEMICOLON       shift and go to state 144


state 93

    (12) procedure_declaration -> PROCEDURE ID LPAREN param_list . RPAREN SEMICOLON function_block SEMICOLON
    (56) param_list -> param_list . SEMICOLON param

    RPAREN          shift and go to state 145
    SEMICOLON       shift and go to state 141


state 94

    (13) procedure_declaration -> PROCEDURE ID SEMICOLON function_block . SEMICOLON

    SEMICOLON       shift and go to state 146


state 95

    (8) function_block -> declarations . compound_statement
    (26) compound_statement -> . BEGIN statement_list END

    BEGIN           shift and go to state 16

    compound_statement             shift and go to state 147

state 96

    (9) function_block -> compound_statement .

    SEMICOLON       reduce using rule 9 (function_block -> compound_statement .)


state 97

    (27) statement_list -> statement_list SEMICOLON statement .

    END             reduce using rule 27 (statement_list -> statement_list SEMICOLON statement .)
    SEMICOLON       reduce using rule 27 (statement_list -> statement_list SEMICOLON statement .)


state 98

    (38) assignment_statement -> variable ASSIGN expression .

    END             reduce using rule 38 (assignment_statement -> variable ASSIGN expression .)
    SEMICOLON       reduce using rule 38 (assignment_statement -> variable ASSIGN expression .)
    ELSE            reduce using rule 38 (assignment_statement -> variable ASSIGN expression .)


state 99

    (39) assignment_statement -> ID ASSIGN expression .

    END             reduce using rule 39 (assignment_statement -> ID ASSIGN expression .)
    SEMICOLON       reduce using rule 39 (assignment_statement -> ID ASSIGN expression .)
    ELSE            reduce using rule 39 (assignment_statement -> ID ASSIGN expression .)


state 100

    (47) procedure_call_statement -> ID LPAREN expression_list . RPAREN
    (95) function_call -> ID LPAREN expression_list . RPAREN
    (54) expression_list -> expression_list . COMMA expression

    RPAREN          shift and go to state 148
    COMMA           shift and go to state 149


state 101

    (48) procedure_call_statement -> ID LPAREN RPAREN .
    (96) function_call -> ID LPAREN RPAREN .

  ! reduce/reduce conflict for END resolved using rule 48 (procedure_call_statement -> ID LPAREN RPAREN .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 48 (procedure_call_statement -> ID LPAREN RPAREN .)
  ! reduce/reduce conflict for ELSE resolved using rule 48 (procedure_call_statement -> ID LPAREN RPAREN .)
    END             reduce using rule 48 (procedure_call_statement -> ID LPAREN RPAREN .)
    SEMICOLON       reduce using rule 48 (procedure_call_statement -> ID LPAREN RPAREN .)
    ELSE            reduce using rule 48 (procedure_call_statement -> ID LPAREN RPAREN .)

  ! END             [ reduce using rule 96 (function_call -> ID LPAREN RPAREN .) ]
  ! SEMICOLON       [ reduce using rule 96 (function_call -> ID LPAREN RPAREN .) ]
  ! ELSE            [ reduce using rule 96 (function_call -> ID LPAREN RPAREN .) ]


state 102

    (55) expression_list -> expression .

    RPAREN          reduce using rule 55 (expression_list -> expression .)
    COMMA           reduce using rule 55 (expression_list -> expression .)


state 103

    (41) variable -> ID LBRACKET expression . RBRACKET

    RBRACKET        shift and go to state 150


state 104

    (42) if_statement -> IF expression THEN . statement
    (43) if_statement -> IF expression THEN . statement ELSE statement
    (29) statement -> . compound_statement
    (30) statement -> . assignment_statement
    (31) statement -> . if_statement
    (32) statement -> . while_statement
    (33) statement -> . for_statement
    (34) statement -> . procedure_call_statement
    (35) statement -> . function_call_statement
    (36) statement -> . halt_statement
    (37) statement -> . empty
    (26) compound_statement -> . BEGIN statement_list END
    (38) assignment_statement -> . variable ASSIGN expression
    (39) assignment_statement -> . ID ASSIGN expression
    (42) if_statement -> . IF expression THEN statement
    (43) if_statement -> . IF expression THEN statement ELSE statement
    (44) while_statement -> . WHILE expression DO statement
    (45) for_statement -> . FOR ID ASSIGN expression TO expression DO statement
    (46) for_statement -> . FOR ID ASSIGN expression DOWNTO expression DO statement
    (47) procedure_call_statement -> . ID LPAREN expression_list RPAREN
    (48) procedure_call_statement -> . ID LPAREN RPAREN
    (49) procedure_call_statement -> . WRITELN LPAREN expression_list RPAREN
    (50) procedure_call_statement -> . WRITELN LPAREN RPAREN
    (51) procedure_call_statement -> . READLN LPAREN variable RPAREN
    (52) procedure_call_statement -> . READLN LPAREN RPAREN
    (53) function_call_statement -> . function_call
    (98) halt_statement -> . HALT
    (99) empty -> .
    (40) variable -> . ID
    (41) variable -> . ID LBRACKET expression RBRACKET
    (95) function_call -> . ID LPAREN expression_list RPAREN
    (96) function_call -> . ID LPAREN RPAREN
    (97) function_call -> . LENGTH LPAREN expression RPAREN

    BEGIN           shift and go to state 16
    ID              shift and go to state 36
    IF              shift and go to state 37
    WHILE           shift and go to state 38
    FOR             shift and go to state 39
    WRITELN         shift and go to state 40
    READLN          shift and go to state 41
    HALT            shift and go to state 43
    ELSE            reduce using rule 99 (empty -> .)
    END             reduce using rule 99 (empty -> .)
    SEMICOLON       reduce using rule 99 (empty -> .)
    LENGTH          shift and go to state 44

    statement                      shift and go to state 151
    compound_statement             shift and go to state 26
    assignment_statement           shift and go to state 27
    if_statement                   shift and go to state 28
    while_statement                shift and go to state 29
    for_statement                  shift and go to state 30
    procedure_call_statement       shift and go to state 31
    function_call_statement        shift and go to state 32
    halt_statement                 shift and go to state 33
    empty                          shift and go to state 34
    variable                       shift and go to state 35
    function_call                  shift and go to state 42

state 105

    (62) expression -> simple_expression relop . simple_expression
    (70) simple_expression -> . term
    (71) simple_expression -> . simple_expression addop term
    (75) term -> . factor
    (76) term -> . term mulop factor
    (82) factor -> . string_access
    (83) factor -> . variable
    (84) factor -> . INTEGER
    (85) factor -> . REAL
    (86) factor -> . STRING
    (87) factor -> . TRUE
    (88) factor -> . FALSE
    (89) factor -> . LPAREN expression RPAREN
    (90) factor -> . NOT factor
    (91) factor -> . function_call
    (92) string_access -> . ID LBRACKET expression RBRACKET
    (40) variable -> . ID
    (41) variable -> . ID LBRACKET expression RBRACKET
    (95) function_call -> . ID LPAREN expression_list RPAREN
    (96) function_call -> . ID LPAREN RPAREN
    (97) function_call -> . LENGTH LPAREN expression RPAREN

    INTEGER         shift and go to state 61
    REAL            shift and go to state 66
    STRING          shift and go to state 67
    TRUE            shift and go to state 68
    FALSE           shift and go to state 69
    LPAREN          shift and go to state 70
    NOT             shift and go to state 71
    ID              shift and go to state 129
    LENGTH          shift and go to state 44

    simple_expression              shift and go to state 152
    term                           shift and go to state 62
    factor                         shift and go to state 64
    string_access                  shift and go to state 65
    variable                       shift and go to state 128
    function_call                  shift and go to state 72

state 106

    (71) simple_expression -> simple_expression addop . term
    (75) term -> . factor
    (76) term -> . term mulop factor
    (82) factor -> . string_access
    (83) factor -> . variable
    (84) factor -> . INTEGER
    (85) factor -> . REAL
    (86) factor -> . STRING
    (87) factor -> . TRUE
    (88) factor -> . FALSE
    (89) factor -> . LPAREN expression RPAREN
    (90) factor -> . NOT factor
    (91) factor -> . function_call
    (92) string_access -> . ID LBRACKET expression RBRACKET
    (40) variable -> . ID
    (41) variable -> . ID LBRACKET expression RBRACKET
    (95) function_call -> . ID LPAREN expression_list RPAREN
    (96) function_call -> . ID LPAREN RPAREN
    (97) function_call -> . LENGTH LPAREN expression RPAREN

    INTEGER         shift and go to state 61
    REAL            shift and go to state 66
    STRING          shift and go to state 67
    TRUE            shift and go to state 68
    FALSE           shift and go to state 69
    LPAREN          shift and go to state 70
    NOT             shift and go to state 71
    ID              shift and go to state 129
    LENGTH          shift and go to state 44

    term                           shift and go to state 153
    factor                         shift and go to state 64
    string_access                  shift and go to state 65
    variable                       shift and go to state 128
    function_call                  shift and go to state 72

state 107

    (63) relop -> EQ .

    INTEGER         reduce using rule 63 (relop -> EQ .)
    REAL            reduce using rule 63 (relop -> EQ .)
    STRING          reduce using rule 63 (relop -> EQ .)
    TRUE            reduce using rule 63 (relop -> EQ .)
    FALSE           reduce using rule 63 (relop -> EQ .)
    LPAREN          reduce using rule 63 (relop -> EQ .)
    NOT             reduce using rule 63 (relop -> EQ .)
    ID              reduce using rule 63 (relop -> EQ .)
    LENGTH          reduce using rule 63 (relop -> EQ .)


state 108

    (64) relop -> NEQ .

    INTEGER         reduce using rule 64 (relop -> NEQ .)
    REAL            reduce using rule 64 (relop -> NEQ .)
    STRING          reduce using rule 64 (relop -> NEQ .)
    TRUE            reduce using rule 64 (relop -> NEQ .)
    FALSE           reduce using rule 64 (relop -> NEQ .)
    LPAREN          reduce using rule 64 (relop -> NEQ .)
    NOT             reduce using rule 64 (relop -> NEQ .)
    ID              reduce using rule 64 (relop -> NEQ .)
    LENGTH          reduce using rule 64 (relop -> NEQ .)


state 109

    (65) relop -> LT .

    INTEGER         reduce using rule 65 (relop -> LT .)
    REAL            reduce using rule 65 (relop -> LT .)
    STRING          reduce using rule 65 (relop -> LT .)
    TRUE            reduce using rule 65 (relop -> LT .)
    FALSE           reduce using rule 65 (relop -> LT .)
    LPAREN          reduce using rule 65 (relop -> LT .)
    NOT             reduce using rule 65 (relop -> LT .)
    ID              reduce using rule 65 (relop -> LT .)
    LENGTH          reduce using rule 65 (relop -> LT .)


state 110

    (66) relop -> LE .

    INTEGER         reduce using rule 66 (relop -> LE .)
    REAL            reduce using rule 66 (relop -> LE .)
    STRING          reduce using rule 66 (relop -> LE .)
    TRUE            reduce using rule 66 (relop -> LE .)
    FALSE           reduce using rule 66 (relop -> LE .)
    LPAREN          reduce using rule 66 (relop -> LE .)
    NOT             reduce using rule 66 (relop -> LE .)
    ID              reduce using rule 66 (relop -> LE .)
    LENGTH          reduce using rule 66 (relop -> LE .)


state 111

    (67) relop -> GT .

    INTEGER         reduce using rule 67 (relop -> GT .)
    REAL            reduce using rule 67 (relop -> GT .)
    STRING          reduce using rule 67 (relop -> GT .)
    TRUE            reduce using rule 67 (relop -> GT .)
    FALSE           reduce using rule 67 (relop -> GT .)
    LPAREN          reduce using rule 67 (relop -> GT .)
    NOT             reduce using rule 67 (relop -> GT .)
    ID              reduce using rule 67 (relop -> GT .)
    LENGTH          reduce using rule 67 (relop -> GT .)


state 112

    (68) relop -> GE .

    INTEGER         reduce using rule 68 (relop -> GE .)
    REAL            reduce using rule 68 (relop -> GE .)
    STRING          reduce using rule 68 (relop -> GE .)
    TRUE            reduce using rule 68 (relop -> GE .)
    FALSE           reduce using rule 68 (relop -> GE .)
    LPAREN          reduce using rule 68 (relop -> GE .)
    NOT             reduce using rule 68 (relop -> GE .)
    ID              reduce using rule 68 (relop -> GE .)
    LENGTH          reduce using rule 68 (relop -> GE .)


state 113

    (69) relop -> IN .

    INTEGER         reduce using rule 69 (relop -> IN .)
    REAL            reduce using rule 69 (relop -> IN .)
    STRING          reduce using rule 69 (relop -> IN .)
    TRUE            reduce using rule 69 (relop -> IN .)
    FALSE           reduce using rule 69 (relop -> IN .)
    LPAREN          reduce using rule 69 (relop -> IN .)
    NOT             reduce using rule 69 (relop -> IN .)
    ID              reduce using rule 69 (relop -> IN .)
    LENGTH          reduce using rule 69 (relop -> IN .)


state 114

    (72) addop -> PLUS .

    INTEGER         reduce using rule 72 (addop -> PLUS .)
    REAL            reduce using rule 72 (addop -> PLUS .)
    STRING          reduce using rule 72 (addop -> PLUS .)
    TRUE            reduce using rule 72 (addop -> PLUS .)
    FALSE           reduce using rule 72 (addop -> PLUS .)
    LPAREN          reduce using rule 72 (addop -> PLUS .)
    NOT             reduce using rule 72 (addop -> PLUS .)
    ID              reduce using rule 72 (addop -> PLUS .)
    LENGTH          reduce using rule 72 (addop -> PLUS .)


state 115

    (73) addop -> MINUS .

    INTEGER         reduce using rule 73 (addop -> MINUS .)
    REAL            reduce using rule 73 (addop -> MINUS .)
    STRING          reduce using rule 73 (addop -> MINUS .)
    TRUE            reduce using rule 73 (addop -> MINUS .)
    FALSE           reduce using rule 73 (addop -> MINUS .)
    LPAREN          reduce using rule 73 (addop -> MINUS .)
    NOT             reduce using rule 73 (addop -> MINUS .)
    ID              reduce using rule 73 (addop -> MINUS .)
    LENGTH          reduce using rule 73 (addop -> MINUS .)


state 116

    (74) addop -> OR .

    INTEGER         reduce using rule 74 (addop -> OR .)
    REAL            reduce using rule 74 (addop -> OR .)
    STRING          reduce using rule 74 (addop -> OR .)
    TRUE            reduce using rule 74 (addop -> OR .)
    FALSE           reduce using rule 74 (addop -> OR .)
    LPAREN          reduce using rule 74 (addop -> OR .)
    NOT             reduce using rule 74 (addop -> OR .)
    ID              reduce using rule 74 (addop -> OR .)
    LENGTH          reduce using rule 74 (addop -> OR .)


state 117

    (93) expression -> variable COLON . INTEGER
    (94) expression -> variable COLON . INTEGER COLON INTEGER

    INTEGER         shift and go to state 154


state 118

    (76) term -> term mulop . factor
    (82) factor -> . string_access
    (83) factor -> . variable
    (84) factor -> . INTEGER
    (85) factor -> . REAL
    (86) factor -> . STRING
    (87) factor -> . TRUE
    (88) factor -> . FALSE
    (89) factor -> . LPAREN expression RPAREN
    (90) factor -> . NOT factor
    (91) factor -> . function_call
    (92) string_access -> . ID LBRACKET expression RBRACKET
    (40) variable -> . ID
    (41) variable -> . ID LBRACKET expression RBRACKET
    (95) function_call -> . ID LPAREN expression_list RPAREN
    (96) function_call -> . ID LPAREN RPAREN
    (97) function_call -> . LENGTH LPAREN expression RPAREN

    INTEGER         shift and go to state 61
    REAL            shift and go to state 66
    STRING          shift and go to state 67
    TRUE            shift and go to state 68
    FALSE           shift and go to state 69
    LPAREN          shift and go to state 70
    NOT             shift and go to state 71
    ID              shift and go to state 129
    LENGTH          shift and go to state 44

    factor                         shift and go to state 155
    string_access                  shift and go to state 65
    variable                       shift and go to state 128
    function_call                  shift and go to state 72

state 119

    (77) mulop -> TIMES .

    INTEGER         reduce using rule 77 (mulop -> TIMES .)
    REAL            reduce using rule 77 (mulop -> TIMES .)
    STRING          reduce using rule 77 (mulop -> TIMES .)
    TRUE            reduce using rule 77 (mulop -> TIMES .)
    FALSE           reduce using rule 77 (mulop -> TIMES .)
    LPAREN          reduce using rule 77 (mulop -> TIMES .)
    NOT             reduce using rule 77 (mulop -> TIMES .)
    ID              reduce using rule 77 (mulop -> TIMES .)
    LENGTH          reduce using rule 77 (mulop -> TIMES .)


state 120

    (78) mulop -> DIVIDE .

    INTEGER         reduce using rule 78 (mulop -> DIVIDE .)
    REAL            reduce using rule 78 (mulop -> DIVIDE .)
    STRING          reduce using rule 78 (mulop -> DIVIDE .)
    TRUE            reduce using rule 78 (mulop -> DIVIDE .)
    FALSE           reduce using rule 78 (mulop -> DIVIDE .)
    LPAREN          reduce using rule 78 (mulop -> DIVIDE .)
    NOT             reduce using rule 78 (mulop -> DIVIDE .)
    ID              reduce using rule 78 (mulop -> DIVIDE .)
    LENGTH          reduce using rule 78 (mulop -> DIVIDE .)


state 121

    (79) mulop -> DIV .

    INTEGER         reduce using rule 79 (mulop -> DIV .)
    REAL            reduce using rule 79 (mulop -> DIV .)
    STRING          reduce using rule 79 (mulop -> DIV .)
    TRUE            reduce using rule 79 (mulop -> DIV .)
    FALSE           reduce using rule 79 (mulop -> DIV .)
    LPAREN          reduce using rule 79 (mulop -> DIV .)
    NOT             reduce using rule 79 (mulop -> DIV .)
    ID              reduce using rule 79 (mulop -> DIV .)
    LENGTH          reduce using rule 79 (mulop -> DIV .)


state 122

    (80) mulop -> MOD .

    INTEGER         reduce using rule 80 (mulop -> MOD .)
    REAL            reduce using rule 80 (mulop -> MOD .)
    STRING          reduce using rule 80 (mulop -> MOD .)
    TRUE            reduce using rule 80 (mulop -> MOD .)
    FALSE           reduce using rule 80 (mulop -> MOD .)
    LPAREN          reduce using rule 80 (mulop -> MOD .)
    NOT             reduce using rule 80 (mulop -> MOD .)
    ID              reduce using rule 80 (mulop -> MOD .)
    LENGTH          reduce using rule 80 (mulop -> MOD .)


state 123

    (81) mulop -> AND .

    INTEGER         reduce using rule 81 (mulop -> AND .)
    REAL            reduce using rule 81 (mulop -> AND .)
    STRING          reduce using rule 81 (mulop -> AND .)
    TRUE            reduce using rule 81 (mulop -> AND .)
    FALSE           reduce using rule 81 (mulop -> AND .)
    LPAREN          reduce using rule 81 (mulop -> AND .)
    NOT             reduce using rule 81 (mulop -> AND .)
    ID              reduce using rule 81 (mulop -> AND .)
    LENGTH          reduce using rule 81 (mulop -> AND .)


state 124

    (41) variable -> ID LBRACKET . expression RBRACKET
    (92) string_access -> ID LBRACKET . expression RBRACKET
    (61) expression -> . simple_expression
    (62) expression -> . simple_expression relop simple_expression
    (93) expression -> . variable COLON INTEGER
    (94) expression -> . variable COLON INTEGER COLON INTEGER
    (70) simple_expression -> . term
    (71) simple_expression -> . simple_expression addop term
    (40) variable -> . ID
    (41) variable -> . ID LBRACKET expression RBRACKET
    (75) term -> . factor
    (76) term -> . term mulop factor
    (82) factor -> . string_access
    (83) factor -> . variable
    (84) factor -> . INTEGER
    (85) factor -> . REAL
    (86) factor -> . STRING
    (87) factor -> . TRUE
    (88) factor -> . FALSE
    (89) factor -> . LPAREN expression RPAREN
    (90) factor -> . NOT factor
    (91) factor -> . function_call
    (92) string_access -> . ID LBRACKET expression RBRACKET
    (95) function_call -> . ID LPAREN expression_list RPAREN
    (96) function_call -> . ID LPAREN RPAREN
    (97) function_call -> . LENGTH LPAREN expression RPAREN

    ID              shift and go to state 63
    INTEGER         shift and go to state 61
    REAL            shift and go to state 66
    STRING          shift and go to state 67
    TRUE            shift and go to state 68
    FALSE           shift and go to state 69
    LPAREN          shift and go to state 70
    NOT             shift and go to state 71
    LENGTH          shift and go to state 44

    expression                     shift and go to state 156
    simple_expression              shift and go to state 59
    variable                       shift and go to state 60
    term                           shift and go to state 62
    factor                         shift and go to state 64
    string_access                  shift and go to state 65
    function_call                  shift and go to state 72

state 125

    (95) function_call -> ID LPAREN . expression_list RPAREN
    (96) function_call -> ID LPAREN . RPAREN
    (54) expression_list -> . expression_list COMMA expression
    (55) expression_list -> . expression
    (61) expression -> . simple_expression
    (62) expression -> . simple_expression relop simple_expression
    (93) expression -> . variable COLON INTEGER
    (94) expression -> . variable COLON INTEGER COLON INTEGER
    (70) simple_expression -> . term
    (71) simple_expression -> . simple_expression addop term
    (40) variable -> . ID
    (41) variable -> . ID LBRACKET expression RBRACKET
    (75) term -> . factor
    (76) term -> . term mulop factor
    (82) factor -> . string_access
    (83) factor -> . variable
    (84) factor -> . INTEGER
    (85) factor -> . REAL
    (86) factor -> . STRING
    (87) factor -> . TRUE
    (88) factor -> . FALSE
    (89) factor -> . LPAREN expression RPAREN
    (90) factor -> . NOT factor
    (91) factor -> . function_call
    (92) string_access -> . ID LBRACKET expression RBRACKET
    (95) function_call -> . ID LPAREN expression_list RPAREN
    (96) function_call -> . ID LPAREN RPAREN
    (97) function_call -> . LENGTH LPAREN expression RPAREN

    RPAREN          shift and go to state 158
    ID              shift and go to state 63
    INTEGER         shift and go to state 61
    REAL            shift and go to state 66
    STRING          shift and go to state 67
    TRUE            shift and go to state 68
    FALSE           shift and go to state 69
    LPAREN          shift and go to state 70
    NOT             shift and go to state 71
    LENGTH          shift and go to state 44

    expression_list                shift and go to state 157
    expression                     shift and go to state 102
    simple_expression              shift and go to state 59
    variable                       shift and go to state 60
    term                           shift and go to state 62
    factor                         shift and go to state 64
    string_access                  shift and go to state 65
    function_call                  shift and go to state 72

state 126

    (89) factor -> LPAREN expression . RPAREN

    RPAREN          shift and go to state 159


state 127

    (90) factor -> NOT factor .

    TIMES           reduce using rule 90 (factor -> NOT factor .)
    DIVIDE          reduce using rule 90 (factor -> NOT factor .)
    DIV             reduce using rule 90 (factor -> NOT factor .)
    MOD             reduce using rule 90 (factor -> NOT factor .)
    AND             reduce using rule 90 (factor -> NOT factor .)
    EQ              reduce using rule 90 (factor -> NOT factor .)
    NEQ             reduce using rule 90 (factor -> NOT factor .)
    LT              reduce using rule 90 (factor -> NOT factor .)
    LE              reduce using rule 90 (factor -> NOT factor .)
    GT              reduce using rule 90 (factor -> NOT factor .)
    GE              reduce using rule 90 (factor -> NOT factor .)
    IN              reduce using rule 90 (factor -> NOT factor .)
    PLUS            reduce using rule 90 (factor -> NOT factor .)
    MINUS           reduce using rule 90 (factor -> NOT factor .)
    OR              reduce using rule 90 (factor -> NOT factor .)
    THEN            reduce using rule 90 (factor -> NOT factor .)
    DO              reduce using rule 90 (factor -> NOT factor .)
    END             reduce using rule 90 (factor -> NOT factor .)
    SEMICOLON       reduce using rule 90 (factor -> NOT factor .)
    ELSE            reduce using rule 90 (factor -> NOT factor .)
    RPAREN          reduce using rule 90 (factor -> NOT factor .)
    COMMA           reduce using rule 90 (factor -> NOT factor .)
    RBRACKET        reduce using rule 90 (factor -> NOT factor .)
    TO              reduce using rule 90 (factor -> NOT factor .)
    DOWNTO          reduce using rule 90 (factor -> NOT factor .)


state 128

    (83) factor -> variable .

    TIMES           reduce using rule 83 (factor -> variable .)
    DIVIDE          reduce using rule 83 (factor -> variable .)
    DIV             reduce using rule 83 (factor -> variable .)
    MOD             reduce using rule 83 (factor -> variable .)
    AND             reduce using rule 83 (factor -> variable .)
    EQ              reduce using rule 83 (factor -> variable .)
    NEQ             reduce using rule 83 (factor -> variable .)
    LT              reduce using rule 83 (factor -> variable .)
    LE              reduce using rule 83 (factor -> variable .)
    GT              reduce using rule 83 (factor -> variable .)
    GE              reduce using rule 83 (factor -> variable .)
    IN              reduce using rule 83 (factor -> variable .)
    PLUS            reduce using rule 83 (factor -> variable .)
    MINUS           reduce using rule 83 (factor -> variable .)
    OR              reduce using rule 83 (factor -> variable .)
    THEN            reduce using rule 83 (factor -> variable .)
    DO              reduce using rule 83 (factor -> variable .)
    END             reduce using rule 83 (factor -> variable .)
    SEMICOLON       reduce using rule 83 (factor -> variable .)
    ELSE            reduce using rule 83 (factor -> variable .)
    RPAREN          reduce using rule 83 (factor -> variable .)
    COMMA           reduce using rule 83 (factor -> variable .)
    RBRACKET        reduce using rule 83 (factor -> variable .)
    TO              reduce using rule 83 (factor -> variable .)
    DOWNTO          reduce using rule 83 (factor -> variable .)


state 129

    (92) string_access -> ID . LBRACKET expression RBRACKET
    (40) variable -> ID .
    (41) variable -> ID . LBRACKET expression RBRACKET
    (95) function_call -> ID . LPAREN expression_list RPAREN
    (96) function_call -> ID . LPAREN RPAREN

    LBRACKET        shift and go to state 160
    TIMES           reduce using rule 40 (variable -> ID .)
    DIVIDE          reduce using rule 40 (variable -> ID .)
    DIV             reduce using rule 40 (variable -> ID .)
    MOD             reduce using rule 40 (variable -> ID .)
    AND             reduce using rule 40 (variable -> ID .)
    EQ              reduce using rule 40 (variable -> ID .)
    NEQ             reduce using rule 40 (variable -> ID .)
    LT              reduce using rule 40 (variable -> ID .)
    LE              reduce using rule 40 (variable -> ID .)
    GT              reduce using rule 40 (variable -> ID .)
    GE              reduce using rule 40 (variable -> ID .)
    IN              reduce using rule 40 (variable -> ID .)
    PLUS            reduce using rule 40 (variable -> ID .)
    MINUS           reduce using rule 40 (variable -> ID .)
    OR              reduce using rule 40 (variable -> ID .)
    THEN            reduce using rule 40 (variable -> ID .)
    DO              reduce using rule 40 (variable -> ID .)
    END             reduce using rule 40 (variable -> ID .)
    SEMICOLON       reduce using rule 40 (variable -> ID .)
    ELSE            reduce using rule 40 (variable -> ID .)
    RPAREN          reduce using rule 40 (variable -> ID .)
    COMMA           reduce using rule 40 (variable -> ID .)
    RBRACKET        reduce using rule 40 (variable -> ID .)
    TO              reduce using rule 40 (variable -> ID .)
    DOWNTO          reduce using rule 40 (variable -> ID .)
    LPAREN          shift and go to state 125


state 130

    (44) while_statement -> WHILE expression DO . statement
    (29) statement -> . compound_statement
    (30) statement -> . assignment_statement
    (31) statement -> . if_statement
    (32) statement -> . while_statement
    (33) statement -> . for_statement
    (34) statement -> . procedure_call_statement
    (35) statement -> . function_call_statement
    (36) statement -> . halt_statement
    (37) statement -> . empty
    (26) compound_statement -> . BEGIN statement_list END
    (38) assignment_statement -> . variable ASSIGN expression
    (39) assignment_statement -> . ID ASSIGN expression
    (42) if_statement -> . IF expression THEN statement
    (43) if_statement -> . IF expression THEN statement ELSE statement
    (44) while_statement -> . WHILE expression DO statement
    (45) for_statement -> . FOR ID ASSIGN expression TO expression DO statement
    (46) for_statement -> . FOR ID ASSIGN expression DOWNTO expression DO statement
    (47) procedure_call_statement -> . ID LPAREN expression_list RPAREN
    (48) procedure_call_statement -> . ID LPAREN RPAREN
    (49) procedure_call_statement -> . WRITELN LPAREN expression_list RPAREN
    (50) procedure_call_statement -> . WRITELN LPAREN RPAREN
    (51) procedure_call_statement -> . READLN LPAREN variable RPAREN
    (52) procedure_call_statement -> . READLN LPAREN RPAREN
    (53) function_call_statement -> . function_call
    (98) halt_statement -> . HALT
    (99) empty -> .
    (40) variable -> . ID
    (41) variable -> . ID LBRACKET expression RBRACKET
    (95) function_call -> . ID LPAREN expression_list RPAREN
    (96) function_call -> . ID LPAREN RPAREN
    (97) function_call -> . LENGTH LPAREN expression RPAREN

    BEGIN           shift and go to state 16
    ID              shift and go to state 36
    IF              shift and go to state 37
    WHILE           shift and go to state 38
    FOR             shift and go to state 39
    WRITELN         shift and go to state 40
    READLN          shift and go to state 41
    HALT            shift and go to state 43
    ELSE            reduce using rule 99 (empty -> .)
    END             reduce using rule 99 (empty -> .)
    SEMICOLON       reduce using rule 99 (empty -> .)
    LENGTH          shift and go to state 44

    statement                      shift and go to state 161
    compound_statement             shift and go to state 26
    assignment_statement           shift and go to state 27
    if_statement                   shift and go to state 28
    while_statement                shift and go to state 29
    for_statement                  shift and go to state 30
    procedure_call_statement       shift and go to state 31
    function_call_statement        shift and go to state 32
    halt_statement                 shift and go to state 33
    empty                          shift and go to state 34
    variable                       shift and go to state 35
    function_call                  shift and go to state 42

state 131

    (45) for_statement -> FOR ID ASSIGN . expression TO expression DO statement
    (46) for_statement -> FOR ID ASSIGN . expression DOWNTO expression DO statement
    (61) expression -> . simple_expression
    (62) expression -> . simple_expression relop simple_expression
    (93) expression -> . variable COLON INTEGER
    (94) expression -> . variable COLON INTEGER COLON INTEGER
    (70) simple_expression -> . term
    (71) simple_expression -> . simple_expression addop term
    (40) variable -> . ID
    (41) variable -> . ID LBRACKET expression RBRACKET
    (75) term -> . factor
    (76) term -> . term mulop factor
    (82) factor -> . string_access
    (83) factor -> . variable
    (84) factor -> . INTEGER
    (85) factor -> . REAL
    (86) factor -> . STRING
    (87) factor -> . TRUE
    (88) factor -> . FALSE
    (89) factor -> . LPAREN expression RPAREN
    (90) factor -> . NOT factor
    (91) factor -> . function_call
    (92) string_access -> . ID LBRACKET expression RBRACKET
    (95) function_call -> . ID LPAREN expression_list RPAREN
    (96) function_call -> . ID LPAREN RPAREN
    (97) function_call -> . LENGTH LPAREN expression RPAREN

    ID              shift and go to state 63
    INTEGER         shift and go to state 61
    REAL            shift and go to state 66
    STRING          shift and go to state 67
    TRUE            shift and go to state 68
    FALSE           shift and go to state 69
    LPAREN          shift and go to state 70
    NOT             shift and go to state 71
    LENGTH          shift and go to state 44

    expression                     shift and go to state 162
    simple_expression              shift and go to state 59
    variable                       shift and go to state 60
    term                           shift and go to state 62
    factor                         shift and go to state 64
    string_access                  shift and go to state 65
    function_call                  shift and go to state 72

state 132

    (49) procedure_call_statement -> WRITELN LPAREN expression_list . RPAREN
    (54) expression_list -> expression_list . COMMA expression

    RPAREN          shift and go to state 163
    COMMA           shift and go to state 149


state 133

    (50) procedure_call_statement -> WRITELN LPAREN RPAREN .

    END             reduce using rule 50 (procedure_call_statement -> WRITELN LPAREN RPAREN .)
    SEMICOLON       reduce using rule 50 (procedure_call_statement -> WRITELN LPAREN RPAREN .)
    ELSE            reduce using rule 50 (procedure_call_statement -> WRITELN LPAREN RPAREN .)


state 134

    (51) procedure_call_statement -> READLN LPAREN variable . RPAREN

    RPAREN          shift and go to state 164


state 135

    (52) procedure_call_statement -> READLN LPAREN RPAREN .

    END             reduce using rule 52 (procedure_call_statement -> READLN LPAREN RPAREN .)
    SEMICOLON       reduce using rule 52 (procedure_call_statement -> READLN LPAREN RPAREN .)
    ELSE            reduce using rule 52 (procedure_call_statement -> READLN LPAREN RPAREN .)


state 136

    (40) variable -> ID .
    (41) variable -> ID . LBRACKET expression RBRACKET

    RPAREN          reduce using rule 40 (variable -> ID .)
    LBRACKET        shift and go to state 57


state 137

    (97) function_call -> LENGTH LPAREN expression . RPAREN

    RPAREN          shift and go to state 165


state 138

    (16) var_declaration -> id_list COLON type_spec SEMICOLON .

    ID              reduce using rule 16 (var_declaration -> id_list COLON type_spec SEMICOLON .)
    VAR             reduce using rule 16 (var_declaration -> id_list COLON type_spec SEMICOLON .)
    FUNCTION        reduce using rule 16 (var_declaration -> id_list COLON type_spec SEMICOLON .)
    PROCEDURE       reduce using rule 16 (var_declaration -> id_list COLON type_spec SEMICOLON .)
    BEGIN           reduce using rule 16 (var_declaration -> id_list COLON type_spec SEMICOLON .)


state 139

    (25) array_type -> ARRAY LBRACKET . INTEGER PERIOD PERIOD INTEGER RBRACKET OF type_spec

    INTEGER         shift and go to state 166


state 140

    (10) function_declaration -> FUNCTION ID LPAREN param_list RPAREN . COLON type_spec SEMICOLON function_block SEMICOLON

    COLON           shift and go to state 167


state 141

    (56) param_list -> param_list SEMICOLON . param
    (59) param -> . id_list COLON type_spec
    (60) param -> . VAR id_list COLON type_spec
    (17) id_list -> . id_list COMMA ID
    (18) id_list -> . ID

    VAR             shift and go to state 91
    ID              shift and go to state 21

    param                          shift and go to state 168
    id_list                        shift and go to state 90

state 142

    (59) param -> id_list COLON . type_spec
    (19) type_spec -> . INTEGER_TYPE
    (20) type_spec -> . REAL_TYPE
    (21) type_spec -> . BOOLEAN
    (22) type_spec -> . STRING_TYPE
    (23) type_spec -> . CHAR_TYPE
    (24) type_spec -> . array_type
    (25) array_type -> . ARRAY LBRACKET INTEGER PERIOD PERIOD INTEGER RBRACKET OF type_spec

    INTEGER_TYPE    shift and go to state 79
    REAL_TYPE       shift and go to state 80
    BOOLEAN         shift and go to state 81
    STRING_TYPE     shift and go to state 82
    CHAR_TYPE       shift and go to state 83
    ARRAY           shift and go to state 85

    type_spec                      shift and go to state 169
    array_type                     shift and go to state 84

state 143

    (60) param -> VAR id_list . COLON type_spec
    (17) id_list -> id_list . COMMA ID

    COLON           shift and go to state 170
    COMMA           shift and go to state 47


state 144

    (11) function_declaration -> FUNCTION ID COLON type_spec SEMICOLON . function_block SEMICOLON
    (8) function_block -> . declarations compound_statement
    (9) function_block -> . compound_statement
    (3) declarations -> . declaration declarations
    (4) declarations -> . empty
    (26) compound_statement -> . BEGIN statement_list END
    (5) declaration -> . VAR var_declarations
    (6) declaration -> . function_declaration
    (7) declaration -> . procedure_declaration
    (99) empty -> .
    (10) function_declaration -> . FUNCTION ID LPAREN param_list RPAREN COLON type_spec SEMICOLON function_block SEMICOLON
    (11) function_declaration -> . FUNCTION ID COLON type_spec SEMICOLON function_block SEMICOLON
    (12) procedure_declaration -> . PROCEDURE ID LPAREN param_list RPAREN SEMICOLON function_block SEMICOLON
    (13) procedure_declaration -> . PROCEDURE ID SEMICOLON function_block SEMICOLON

  ! shift/reduce conflict for BEGIN resolved as shift
    BEGIN           shift and go to state 16
    VAR             shift and go to state 9
    FUNCTION        shift and go to state 12
    PROCEDURE       shift and go to state 13

  ! BEGIN           [ reduce using rule 99 (empty -> .) ]

    function_block                 shift and go to state 171
    declarations                   shift and go to state 95
    compound_statement             shift and go to state 96
    declaration                    shift and go to state 7
    empty                          shift and go to state 8
    function_declaration           shift and go to state 10
    procedure_declaration          shift and go to state 11

state 145

    (12) procedure_declaration -> PROCEDURE ID LPAREN param_list RPAREN . SEMICOLON function_block SEMICOLON

    SEMICOLON       shift and go to state 172


state 146

    (13) procedure_declaration -> PROCEDURE ID SEMICOLON function_block SEMICOLON .

    VAR             reduce using rule 13 (procedure_declaration -> PROCEDURE ID SEMICOLON function_block SEMICOLON .)
    FUNCTION        reduce using rule 13 (procedure_declaration -> PROCEDURE ID SEMICOLON function_block SEMICOLON .)
    PROCEDURE       reduce using rule 13 (procedure_declaration -> PROCEDURE ID SEMICOLON function_block SEMICOLON .)
    BEGIN           reduce using rule 13 (procedure_declaration -> PROCEDURE ID SEMICOLON function_block SEMICOLON .)


state 147

    (8) function_block -> declarations compound_statement .

    SEMICOLON       reduce using rule 8 (function_block -> declarations compound_statement .)


state 148

    (47) procedure_call_statement -> ID LPAREN expression_list RPAREN .
    (95) function_call -> ID LPAREN expression_list RPAREN .

  ! reduce/reduce conflict for END resolved using rule 47 (procedure_call_statement -> ID LPAREN expression_list RPAREN .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 47 (procedure_call_statement -> ID LPAREN expression_list RPAREN .)
  ! reduce/reduce conflict for ELSE resolved using rule 47 (procedure_call_statement -> ID LPAREN expression_list RPAREN .)
    END             reduce using rule 47 (procedure_call_statement -> ID LPAREN expression_list RPAREN .)
    SEMICOLON       reduce using rule 47 (procedure_call_statement -> ID LPAREN expression_list RPAREN .)
    ELSE            reduce using rule 47 (procedure_call_statement -> ID LPAREN expression_list RPAREN .)

  ! END             [ reduce using rule 95 (function_call -> ID LPAREN expression_list RPAREN .) ]
  ! SEMICOLON       [ reduce using rule 95 (function_call -> ID LPAREN expression_list RPAREN .) ]
  ! ELSE            [ reduce using rule 95 (function_call -> ID LPAREN expression_list RPAREN .) ]


state 149

    (54) expression_list -> expression_list COMMA . expression
    (61) expression -> . simple_expression
    (62) expression -> . simple_expression relop simple_expression
    (93) expression -> . variable COLON INTEGER
    (94) expression -> . variable COLON INTEGER COLON INTEGER
    (70) simple_expression -> . term
    (71) simple_expression -> . simple_expression addop term
    (40) variable -> . ID
    (41) variable -> . ID LBRACKET expression RBRACKET
    (75) term -> . factor
    (76) term -> . term mulop factor
    (82) factor -> . string_access
    (83) factor -> . variable
    (84) factor -> . INTEGER
    (85) factor -> . REAL
    (86) factor -> . STRING
    (87) factor -> . TRUE
    (88) factor -> . FALSE
    (89) factor -> . LPAREN expression RPAREN
    (90) factor -> . NOT factor
    (91) factor -> . function_call
    (92) string_access -> . ID LBRACKET expression RBRACKET
    (95) function_call -> . ID LPAREN expression_list RPAREN
    (96) function_call -> . ID LPAREN RPAREN
    (97) function_call -> . LENGTH LPAREN expression RPAREN

    ID              shift and go to state 63
    INTEGER         shift and go to state 61
    REAL            shift and go to state 66
    STRING          shift and go to state 67
    TRUE            shift and go to state 68
    FALSE           shift and go to state 69
    LPAREN          shift and go to state 70
    NOT             shift and go to state 71
    LENGTH          shift and go to state 44

    expression                     shift and go to state 173
    simple_expression              shift and go to state 59
    variable                       shift and go to state 60
    term                           shift and go to state 62
    factor                         shift and go to state 64
    string_access                  shift and go to state 65
    function_call                  shift and go to state 72

state 150

    (41) variable -> ID LBRACKET expression RBRACKET .

    ASSIGN          reduce using rule 41 (variable -> ID LBRACKET expression RBRACKET .)
    RPAREN          reduce using rule 41 (variable -> ID LBRACKET expression RBRACKET .)


state 151

    (42) if_statement -> IF expression THEN statement .
    (43) if_statement -> IF expression THEN statement . ELSE statement

  ! shift/reduce conflict for ELSE resolved as shift
    END             reduce using rule 42 (if_statement -> IF expression THEN statement .)
    SEMICOLON       reduce using rule 42 (if_statement -> IF expression THEN statement .)
    ELSE            shift and go to state 174

  ! ELSE            [ reduce using rule 42 (if_statement -> IF expression THEN statement .) ]


state 152

    (62) expression -> simple_expression relop simple_expression .
    (71) simple_expression -> simple_expression . addop term
    (72) addop -> . PLUS
    (73) addop -> . MINUS
    (74) addop -> . OR

    THEN            reduce using rule 62 (expression -> simple_expression relop simple_expression .)
    DO              reduce using rule 62 (expression -> simple_expression relop simple_expression .)
    END             reduce using rule 62 (expression -> simple_expression relop simple_expression .)
    SEMICOLON       reduce using rule 62 (expression -> simple_expression relop simple_expression .)
    ELSE            reduce using rule 62 (expression -> simple_expression relop simple_expression .)
    RPAREN          reduce using rule 62 (expression -> simple_expression relop simple_expression .)
    COMMA           reduce using rule 62 (expression -> simple_expression relop simple_expression .)
    RBRACKET        reduce using rule 62 (expression -> simple_expression relop simple_expression .)
    TO              reduce using rule 62 (expression -> simple_expression relop simple_expression .)
    DOWNTO          reduce using rule 62 (expression -> simple_expression relop simple_expression .)
    PLUS            shift and go to state 114
    MINUS           shift and go to state 115
    OR              shift and go to state 116

    addop                          shift and go to state 106

state 153

    (71) simple_expression -> simple_expression addop term .
    (76) term -> term . mulop factor
    (77) mulop -> . TIMES
    (78) mulop -> . DIVIDE
    (79) mulop -> . DIV
    (80) mulop -> . MOD
    (81) mulop -> . AND

    EQ              reduce using rule 71 (simple_expression -> simple_expression addop term .)
    NEQ             reduce using rule 71 (simple_expression -> simple_expression addop term .)
    LT              reduce using rule 71 (simple_expression -> simple_expression addop term .)
    LE              reduce using rule 71 (simple_expression -> simple_expression addop term .)
    GT              reduce using rule 71 (simple_expression -> simple_expression addop term .)
    GE              reduce using rule 71 (simple_expression -> simple_expression addop term .)
    IN              reduce using rule 71 (simple_expression -> simple_expression addop term .)
    PLUS            reduce using rule 71 (simple_expression -> simple_expression addop term .)
    MINUS           reduce using rule 71 (simple_expression -> simple_expression addop term .)
    OR              reduce using rule 71 (simple_expression -> simple_expression addop term .)
    THEN            reduce using rule 71 (simple_expression -> simple_expression addop term .)
    DO              reduce using rule 71 (simple_expression -> simple_expression addop term .)
    END             reduce using rule 71 (simple_expression -> simple_expression addop term .)
    SEMICOLON       reduce using rule 71 (simple_expression -> simple_expression addop term .)
    ELSE            reduce using rule 71 (simple_expression -> simple_expression addop term .)
    RPAREN          reduce using rule 71 (simple_expression -> simple_expression addop term .)
    COMMA           reduce using rule 71 (simple_expression -> simple_expression addop term .)
    RBRACKET        reduce using rule 71 (simple_expression -> simple_expression addop term .)
    TO              reduce using rule 71 (simple_expression -> simple_expression addop term .)
    DOWNTO          reduce using rule 71 (simple_expression -> simple_expression addop term .)
    TIMES           shift and go to state 119
    DIVIDE          shift and go to state 120
    DIV             shift and go to state 121
    MOD             shift and go to state 122
    AND             shift and go to state 123

    mulop                          shift and go to state 118

state 154

    (93) expression -> variable COLON INTEGER .
    (94) expression -> variable COLON INTEGER . COLON INTEGER

    THEN            reduce using rule 93 (expression -> variable COLON INTEGER .)
    DO              reduce using rule 93 (expression -> variable COLON INTEGER .)
    END             reduce using rule 93 (expression -> variable COLON INTEGER .)
    SEMICOLON       reduce using rule 93 (expression -> variable COLON INTEGER .)
    ELSE            reduce using rule 93 (expression -> variable COLON INTEGER .)
    RPAREN          reduce using rule 93 (expression -> variable COLON INTEGER .)
    COMMA           reduce using rule 93 (expression -> variable COLON INTEGER .)
    RBRACKET        reduce using rule 93 (expression -> variable COLON INTEGER .)
    TO              reduce using rule 93 (expression -> variable COLON INTEGER .)
    DOWNTO          reduce using rule 93 (expression -> variable COLON INTEGER .)
    COLON           shift and go to state 175


state 155

    (76) term -> term mulop factor .

    TIMES           reduce using rule 76 (term -> term mulop factor .)
    DIVIDE          reduce using rule 76 (term -> term mulop factor .)
    DIV             reduce using rule 76 (term -> term mulop factor .)
    MOD             reduce using rule 76 (term -> term mulop factor .)
    AND             reduce using rule 76 (term -> term mulop factor .)
    EQ              reduce using rule 76 (term -> term mulop factor .)
    NEQ             reduce using rule 76 (term -> term mulop factor .)
    LT              reduce using rule 76 (term -> term mulop factor .)
    LE              reduce using rule 76 (term -> term mulop factor .)
    GT              reduce using rule 76 (term -> term mulop factor .)
    GE              reduce using rule 76 (term -> term mulop factor .)
    IN              reduce using rule 76 (term -> term mulop factor .)
    PLUS            reduce using rule 76 (term -> term mulop factor .)
    MINUS           reduce using rule 76 (term -> term mulop factor .)
    OR              reduce using rule 76 (term -> term mulop factor .)
    THEN            reduce using rule 76 (term -> term mulop factor .)
    DO              reduce using rule 76 (term -> term mulop factor .)
    END             reduce using rule 76 (term -> term mulop factor .)
    SEMICOLON       reduce using rule 76 (term -> term mulop factor .)
    ELSE            reduce using rule 76 (term -> term mulop factor .)
    RPAREN          reduce using rule 76 (term -> term mulop factor .)
    COMMA           reduce using rule 76 (term -> term mulop factor .)
    RBRACKET        reduce using rule 76 (term -> term mulop factor .)
    TO              reduce using rule 76 (term -> term mulop factor .)
    DOWNTO          reduce using rule 76 (term -> term mulop factor .)


state 156

    (41) variable -> ID LBRACKET expression . RBRACKET
    (92) string_access -> ID LBRACKET expression . RBRACKET

    RBRACKET        shift and go to state 176


state 157

    (95) function_call -> ID LPAREN expression_list . RPAREN
    (54) expression_list -> expression_list . COMMA expression

    RPAREN          shift and go to state 177
    COMMA           shift and go to state 149


state 158

    (96) function_call -> ID LPAREN RPAREN .

    TIMES           reduce using rule 96 (function_call -> ID LPAREN RPAREN .)
    DIVIDE          reduce using rule 96 (function_call -> ID LPAREN RPAREN .)
    DIV             reduce using rule 96 (function_call -> ID LPAREN RPAREN .)
    MOD             reduce using rule 96 (function_call -> ID LPAREN RPAREN .)
    AND             reduce using rule 96 (function_call -> ID LPAREN RPAREN .)
    EQ              reduce using rule 96 (function_call -> ID LPAREN RPAREN .)
    NEQ             reduce using rule 96 (function_call -> ID LPAREN RPAREN .)
    LT              reduce using rule 96 (function_call -> ID LPAREN RPAREN .)
    LE              reduce using rule 96 (function_call -> ID LPAREN RPAREN .)
    GT              reduce using rule 96 (function_call -> ID LPAREN RPAREN .)
    GE              reduce using rule 96 (function_call -> ID LPAREN RPAREN .)
    IN              reduce using rule 96 (function_call -> ID LPAREN RPAREN .)
    PLUS            reduce using rule 96 (function_call -> ID LPAREN RPAREN .)
    MINUS           reduce using rule 96 (function_call -> ID LPAREN RPAREN .)
    OR              reduce using rule 96 (function_call -> ID LPAREN RPAREN .)
    THEN            reduce using rule 96 (function_call -> ID LPAREN RPAREN .)
    DO              reduce using rule 96 (function_call -> ID LPAREN RPAREN .)
    END             reduce using rule 96 (function_call -> ID LPAREN RPAREN .)
    SEMICOLON       reduce using rule 96 (function_call -> ID LPAREN RPAREN .)
    ELSE            reduce using rule 96 (function_call -> ID LPAREN RPAREN .)
    RPAREN          reduce using rule 96 (function_call -> ID LPAREN RPAREN .)
    COMMA           reduce using rule 96 (function_call -> ID LPAREN RPAREN .)
    RBRACKET        reduce using rule 96 (function_call -> ID LPAREN RPAREN .)
    TO              reduce using rule 96 (function_call -> ID LPAREN RPAREN .)
    DOWNTO          reduce using rule 96 (function_call -> ID LPAREN RPAREN .)


state 159

    (89) factor -> LPAREN expression RPAREN .

    TIMES           reduce using rule 89 (factor -> LPAREN expression RPAREN .)
    DIVIDE          reduce using rule 89 (factor -> LPAREN expression RPAREN .)
    DIV             reduce using rule 89 (factor -> LPAREN expression RPAREN .)
    MOD             reduce using rule 89 (factor -> LPAREN expression RPAREN .)
    AND             reduce using rule 89 (factor -> LPAREN expression RPAREN .)
    EQ              reduce using rule 89 (factor -> LPAREN expression RPAREN .)
    NEQ             reduce using rule 89 (factor -> LPAREN expression RPAREN .)
    LT              reduce using rule 89 (factor -> LPAREN expression RPAREN .)
    LE              reduce using rule 89 (factor -> LPAREN expression RPAREN .)
    GT              reduce using rule 89 (factor -> LPAREN expression RPAREN .)
    GE              reduce using rule 89 (factor -> LPAREN expression RPAREN .)
    IN              reduce using rule 89 (factor -> LPAREN expression RPAREN .)
    PLUS            reduce using rule 89 (factor -> LPAREN expression RPAREN .)
    MINUS           reduce using rule 89 (factor -> LPAREN expression RPAREN .)
    OR              reduce using rule 89 (factor -> LPAREN expression RPAREN .)
    THEN            reduce using rule 89 (factor -> LPAREN expression RPAREN .)
    DO              reduce using rule 89 (factor -> LPAREN expression RPAREN .)
    END             reduce using rule 89 (factor -> LPAREN expression RPAREN .)
    SEMICOLON       reduce using rule 89 (factor -> LPAREN expression RPAREN .)
    ELSE            reduce using rule 89 (factor -> LPAREN expression RPAREN .)
    RPAREN          reduce using rule 89 (factor -> LPAREN expression RPAREN .)
    COMMA           reduce using rule 89 (factor -> LPAREN expression RPAREN .)
    RBRACKET        reduce using rule 89 (factor -> LPAREN expression RPAREN .)
    TO              reduce using rule 89 (factor -> LPAREN expression RPAREN .)
    DOWNTO          reduce using rule 89 (factor -> LPAREN expression RPAREN .)


state 160

    (92) string_access -> ID LBRACKET . expression RBRACKET
    (41) variable -> ID LBRACKET . expression RBRACKET
    (61) expression -> . simple_expression
    (62) expression -> . simple_expression relop simple_expression
    (93) expression -> . variable COLON INTEGER
    (94) expression -> . variable COLON INTEGER COLON INTEGER
    (70) simple_expression -> . term
    (71) simple_expression -> . simple_expression addop term
    (40) variable -> . ID
    (41) variable -> . ID LBRACKET expression RBRACKET
    (75) term -> . factor
    (76) term -> . term mulop factor
    (82) factor -> . string_access
    (83) factor -> . variable
    (84) factor -> . INTEGER
    (85) factor -> . REAL
    (86) factor -> . STRING
    (87) factor -> . TRUE
    (88) factor -> . FALSE
    (89) factor -> . LPAREN expression RPAREN
    (90) factor -> . NOT factor
    (91) factor -> . function_call
    (92) string_access -> . ID LBRACKET expression RBRACKET
    (95) function_call -> . ID LPAREN expression_list RPAREN
    (96) function_call -> . ID LPAREN RPAREN
    (97) function_call -> . LENGTH LPAREN expression RPAREN

    ID              shift and go to state 63
    INTEGER         shift and go to state 61
    REAL            shift and go to state 66
    STRING          shift and go to state 67
    TRUE            shift and go to state 68
    FALSE           shift and go to state 69
    LPAREN          shift and go to state 70
    NOT             shift and go to state 71
    LENGTH          shift and go to state 44

    expression                     shift and go to state 178
    simple_expression              shift and go to state 59
    variable                       shift and go to state 60
    term                           shift and go to state 62
    factor                         shift and go to state 64
    string_access                  shift and go to state 65
    function_call                  shift and go to state 72

state 161

    (44) while_statement -> WHILE expression DO statement .

    END             reduce using rule 44 (while_statement -> WHILE expression DO statement .)
    SEMICOLON       reduce using rule 44 (while_statement -> WHILE expression DO statement .)
    ELSE            reduce using rule 44 (while_statement -> WHILE expression DO statement .)


state 162

    (45) for_statement -> FOR ID ASSIGN expression . TO expression DO statement
    (46) for_statement -> FOR ID ASSIGN expression . DOWNTO expression DO statement

    TO              shift and go to state 179
    DOWNTO          shift and go to state 180


state 163

    (49) procedure_call_statement -> WRITELN LPAREN expression_list RPAREN .

    END             reduce using rule 49 (procedure_call_statement -> WRITELN LPAREN expression_list RPAREN .)
    SEMICOLON       reduce using rule 49 (procedure_call_statement -> WRITELN LPAREN expression_list RPAREN .)
    ELSE            reduce using rule 49 (procedure_call_statement -> WRITELN LPAREN expression_list RPAREN .)


state 164

    (51) procedure_call_statement -> READLN LPAREN variable RPAREN .

    END             reduce using rule 51 (procedure_call_statement -> READLN LPAREN variable RPAREN .)
    SEMICOLON       reduce using rule 51 (procedure_call_statement -> READLN LPAREN variable RPAREN .)
    ELSE            reduce using rule 51 (procedure_call_statement -> READLN LPAREN variable RPAREN .)


state 165

    (97) function_call -> LENGTH LPAREN expression RPAREN .

    END             reduce using rule 97 (function_call -> LENGTH LPAREN expression RPAREN .)
    SEMICOLON       reduce using rule 97 (function_call -> LENGTH LPAREN expression RPAREN .)
    TIMES           reduce using rule 97 (function_call -> LENGTH LPAREN expression RPAREN .)
    DIVIDE          reduce using rule 97 (function_call -> LENGTH LPAREN expression RPAREN .)
    DIV             reduce using rule 97 (function_call -> LENGTH LPAREN expression RPAREN .)
    MOD             reduce using rule 97 (function_call -> LENGTH LPAREN expression RPAREN .)
    AND             reduce using rule 97 (function_call -> LENGTH LPAREN expression RPAREN .)
    EQ              reduce using rule 97 (function_call -> LENGTH LPAREN expression RPAREN .)
    NEQ             reduce using rule 97 (function_call -> LENGTH LPAREN expression RPAREN .)
    LT              reduce using rule 97 (function_call -> LENGTH LPAREN expression RPAREN .)
    LE              reduce using rule 97 (function_call -> LENGTH LPAREN expression RPAREN .)
    GT              reduce using rule 97 (function_call -> LENGTH LPAREN expression RPAREN .)
    GE              reduce using rule 97 (function_call -> LENGTH LPAREN expression RPAREN .)
    IN              reduce using rule 97 (function_call -> LENGTH LPAREN expression RPAREN .)
    PLUS            reduce using rule 97 (function_call -> LENGTH LPAREN expression RPAREN .)
    MINUS           reduce using rule 97 (function_call -> LENGTH LPAREN expression RPAREN .)
    OR              reduce using rule 97 (function_call -> LENGTH LPAREN expression RPAREN .)
    THEN            reduce using rule 97 (function_call -> LENGTH LPAREN expression RPAREN .)
    DO              reduce using rule 97 (function_call -> LENGTH LPAREN expression RPAREN .)
    ELSE            reduce using rule 97 (function_call -> LENGTH LPAREN expression RPAREN .)
    RPAREN          reduce using rule 97 (function_call -> LENGTH LPAREN expression RPAREN .)
    COMMA           reduce using rule 97 (function_call -> LENGTH LPAREN expression RPAREN .)
    RBRACKET        reduce using rule 97 (function_call -> LENGTH LPAREN expression RPAREN .)
    TO              reduce using rule 97 (function_call -> LENGTH LPAREN expression RPAREN .)
    DOWNTO          reduce using rule 97 (function_call -> LENGTH LPAREN expression RPAREN .)


state 166

    (25) array_type -> ARRAY LBRACKET INTEGER . PERIOD PERIOD INTEGER RBRACKET OF type_spec

    PERIOD          shift and go to state 181


state 167

    (10) function_declaration -> FUNCTION ID LPAREN param_list RPAREN COLON . type_spec SEMICOLON function_block SEMICOLON
    (19) type_spec -> . INTEGER_TYPE
    (20) type_spec -> . REAL_TYPE
    (21) type_spec -> . BOOLEAN
    (22) type_spec -> . STRING_TYPE
    (23) type_spec -> . CHAR_TYPE
    (24) type_spec -> . array_type
    (25) array_type -> . ARRAY LBRACKET INTEGER PERIOD PERIOD INTEGER RBRACKET OF type_spec

    INTEGER_TYPE    shift and go to state 79
    REAL_TYPE       shift and go to state 80
    BOOLEAN         shift and go to state 81
    STRING_TYPE     shift and go to state 82
    CHAR_TYPE       shift and go to state 83
    ARRAY           shift and go to state 85

    type_spec                      shift and go to state 182
    array_type                     shift and go to state 84

state 168

    (56) param_list -> param_list SEMICOLON param .

    RPAREN          reduce using rule 56 (param_list -> param_list SEMICOLON param .)
    SEMICOLON       reduce using rule 56 (param_list -> param_list SEMICOLON param .)


state 169

    (59) param -> id_list COLON type_spec .

    RPAREN          reduce using rule 59 (param -> id_list COLON type_spec .)
    SEMICOLON       reduce using rule 59 (param -> id_list COLON type_spec .)


state 170

    (60) param -> VAR id_list COLON . type_spec
    (19) type_spec -> . INTEGER_TYPE
    (20) type_spec -> . REAL_TYPE
    (21) type_spec -> . BOOLEAN
    (22) type_spec -> . STRING_TYPE
    (23) type_spec -> . CHAR_TYPE
    (24) type_spec -> . array_type
    (25) array_type -> . ARRAY LBRACKET INTEGER PERIOD PERIOD INTEGER RBRACKET OF type_spec

    INTEGER_TYPE    shift and go to state 79
    REAL_TYPE       shift and go to state 80
    BOOLEAN         shift and go to state 81
    STRING_TYPE     shift and go to state 82
    CHAR_TYPE       shift and go to state 83
    ARRAY           shift and go to state 85

    type_spec                      shift and go to state 183
    array_type                     shift and go to state 84

state 171

    (11) function_declaration -> FUNCTION ID COLON type_spec SEMICOLON function_block . SEMICOLON

    SEMICOLON       shift and go to state 184


state 172

    (12) procedure_declaration -> PROCEDURE ID LPAREN param_list RPAREN SEMICOLON . function_block SEMICOLON
    (8) function_block -> . declarations compound_statement
    (9) function_block -> . compound_statement
    (3) declarations -> . declaration declarations
    (4) declarations -> . empty
    (26) compound_statement -> . BEGIN statement_list END
    (5) declaration -> . VAR var_declarations
    (6) declaration -> . function_declaration
    (7) declaration -> . procedure_declaration
    (99) empty -> .
    (10) function_declaration -> . FUNCTION ID LPAREN param_list RPAREN COLON type_spec SEMICOLON function_block SEMICOLON
    (11) function_declaration -> . FUNCTION ID COLON type_spec SEMICOLON function_block SEMICOLON
    (12) procedure_declaration -> . PROCEDURE ID LPAREN param_list RPAREN SEMICOLON function_block SEMICOLON
    (13) procedure_declaration -> . PROCEDURE ID SEMICOLON function_block SEMICOLON

  ! shift/reduce conflict for BEGIN resolved as shift
    BEGIN           shift and go to state 16
    VAR             shift and go to state 9
    FUNCTION        shift and go to state 12
    PROCEDURE       shift and go to state 13

  ! BEGIN           [ reduce using rule 99 (empty -> .) ]

    function_block                 shift and go to state 185
    declarations                   shift and go to state 95
    compound_statement             shift and go to state 96
    declaration                    shift and go to state 7
    empty                          shift and go to state 8
    function_declaration           shift and go to state 10
    procedure_declaration          shift and go to state 11

state 173

    (54) expression_list -> expression_list COMMA expression .

    RPAREN          reduce using rule 54 (expression_list -> expression_list COMMA expression .)
    COMMA           reduce using rule 54 (expression_list -> expression_list COMMA expression .)


state 174

    (43) if_statement -> IF expression THEN statement ELSE . statement
    (29) statement -> . compound_statement
    (30) statement -> . assignment_statement
    (31) statement -> . if_statement
    (32) statement -> . while_statement
    (33) statement -> . for_statement
    (34) statement -> . procedure_call_statement
    (35) statement -> . function_call_statement
    (36) statement -> . halt_statement
    (37) statement -> . empty
    (26) compound_statement -> . BEGIN statement_list END
    (38) assignment_statement -> . variable ASSIGN expression
    (39) assignment_statement -> . ID ASSIGN expression
    (42) if_statement -> . IF expression THEN statement
    (43) if_statement -> . IF expression THEN statement ELSE statement
    (44) while_statement -> . WHILE expression DO statement
    (45) for_statement -> . FOR ID ASSIGN expression TO expression DO statement
    (46) for_statement -> . FOR ID ASSIGN expression DOWNTO expression DO statement
    (47) procedure_call_statement -> . ID LPAREN expression_list RPAREN
    (48) procedure_call_statement -> . ID LPAREN RPAREN
    (49) procedure_call_statement -> . WRITELN LPAREN expression_list RPAREN
    (50) procedure_call_statement -> . WRITELN LPAREN RPAREN
    (51) procedure_call_statement -> . READLN LPAREN variable RPAREN
    (52) procedure_call_statement -> . READLN LPAREN RPAREN
    (53) function_call_statement -> . function_call
    (98) halt_statement -> . HALT
    (99) empty -> .
    (40) variable -> . ID
    (41) variable -> . ID LBRACKET expression RBRACKET
    (95) function_call -> . ID LPAREN expression_list RPAREN
    (96) function_call -> . ID LPAREN RPAREN
    (97) function_call -> . LENGTH LPAREN expression RPAREN

    BEGIN           shift and go to state 16
    ID              shift and go to state 36
    IF              shift and go to state 37
    WHILE           shift and go to state 38
    FOR             shift and go to state 39
    WRITELN         shift and go to state 40
    READLN          shift and go to state 41
    HALT            shift and go to state 43
    ELSE            reduce using rule 99 (empty -> .)
    END             reduce using rule 99 (empty -> .)
    SEMICOLON       reduce using rule 99 (empty -> .)
    LENGTH          shift and go to state 44

    statement                      shift and go to state 186
    compound_statement             shift and go to state 26
    assignment_statement           shift and go to state 27
    if_statement                   shift and go to state 28
    while_statement                shift and go to state 29
    for_statement                  shift and go to state 30
    procedure_call_statement       shift and go to state 31
    function_call_statement        shift and go to state 32
    halt_statement                 shift and go to state 33
    empty                          shift and go to state 34
    variable                       shift and go to state 35
    function_call                  shift and go to state 42

state 175

    (94) expression -> variable COLON INTEGER COLON . INTEGER

    INTEGER         shift and go to state 187


state 176

    (41) variable -> ID LBRACKET expression RBRACKET .
    (92) string_access -> ID LBRACKET expression RBRACKET .

  ! reduce/reduce conflict for TIMES resolved using rule 41 (variable -> ID LBRACKET expression RBRACKET .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 41 (variable -> ID LBRACKET expression RBRACKET .)
  ! reduce/reduce conflict for DIV resolved using rule 41 (variable -> ID LBRACKET expression RBRACKET .)
  ! reduce/reduce conflict for MOD resolved using rule 41 (variable -> ID LBRACKET expression RBRACKET .)
  ! reduce/reduce conflict for AND resolved using rule 41 (variable -> ID LBRACKET expression RBRACKET .)
  ! reduce/reduce conflict for EQ resolved using rule 41 (variable -> ID LBRACKET expression RBRACKET .)
  ! reduce/reduce conflict for NEQ resolved using rule 41 (variable -> ID LBRACKET expression RBRACKET .)
  ! reduce/reduce conflict for LT resolved using rule 41 (variable -> ID LBRACKET expression RBRACKET .)
  ! reduce/reduce conflict for LE resolved using rule 41 (variable -> ID LBRACKET expression RBRACKET .)
  ! reduce/reduce conflict for GT resolved using rule 41 (variable -> ID LBRACKET expression RBRACKET .)
  ! reduce/reduce conflict for GE resolved using rule 41 (variable -> ID LBRACKET expression RBRACKET .)
  ! reduce/reduce conflict for IN resolved using rule 41 (variable -> ID LBRACKET expression RBRACKET .)
  ! reduce/reduce conflict for PLUS resolved using rule 41 (variable -> ID LBRACKET expression RBRACKET .)
  ! reduce/reduce conflict for MINUS resolved using rule 41 (variable -> ID LBRACKET expression RBRACKET .)
  ! reduce/reduce conflict for OR resolved using rule 41 (variable -> ID LBRACKET expression RBRACKET .)
  ! reduce/reduce conflict for THEN resolved using rule 41 (variable -> ID LBRACKET expression RBRACKET .)
  ! reduce/reduce conflict for DO resolved using rule 41 (variable -> ID LBRACKET expression RBRACKET .)
  ! reduce/reduce conflict for END resolved using rule 41 (variable -> ID LBRACKET expression RBRACKET .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 41 (variable -> ID LBRACKET expression RBRACKET .)
  ! reduce/reduce conflict for ELSE resolved using rule 41 (variable -> ID LBRACKET expression RBRACKET .)
  ! reduce/reduce conflict for RPAREN resolved using rule 41 (variable -> ID LBRACKET expression RBRACKET .)
  ! reduce/reduce conflict for COMMA resolved using rule 41 (variable -> ID LBRACKET expression RBRACKET .)
  ! reduce/reduce conflict for RBRACKET resolved using rule 41 (variable -> ID LBRACKET expression RBRACKET .)
  ! reduce/reduce conflict for TO resolved using rule 41 (variable -> ID LBRACKET expression RBRACKET .)
  ! reduce/reduce conflict for DOWNTO resolved using rule 41 (variable -> ID LBRACKET expression RBRACKET .)
    COLON           reduce using rule 41 (variable -> ID LBRACKET expression RBRACKET .)
    TIMES           reduce using rule 41 (variable -> ID LBRACKET expression RBRACKET .)
    DIVIDE          reduce using rule 41 (variable -> ID LBRACKET expression RBRACKET .)
    DIV             reduce using rule 41 (variable -> ID LBRACKET expression RBRACKET .)
    MOD             reduce using rule 41 (variable -> ID LBRACKET expression RBRACKET .)
    AND             reduce using rule 41 (variable -> ID LBRACKET expression RBRACKET .)
    EQ              reduce using rule 41 (variable -> ID LBRACKET expression RBRACKET .)
    NEQ             reduce using rule 41 (variable -> ID LBRACKET expression RBRACKET .)
    LT              reduce using rule 41 (variable -> ID LBRACKET expression RBRACKET .)
    LE              reduce using rule 41 (variable -> ID LBRACKET expression RBRACKET .)
    GT              reduce using rule 41 (variable -> ID LBRACKET expression RBRACKET .)
    GE              reduce using rule 41 (variable -> ID LBRACKET expression RBRACKET .)
    IN              reduce using rule 41 (variable -> ID LBRACKET expression RBRACKET .)
    PLUS            reduce using rule 41 (variable -> ID LBRACKET expression RBRACKET .)
    MINUS           reduce using rule 41 (variable -> ID LBRACKET expression RBRACKET .)
    OR              reduce using rule 41 (variable -> ID LBRACKET expression RBRACKET .)
    THEN            reduce using rule 41 (variable -> ID LBRACKET expression RBRACKET .)
    DO              reduce using rule 41 (variable -> ID LBRACKET expression RBRACKET .)
    END             reduce using rule 41 (variable -> ID LBRACKET expression RBRACKET .)
    SEMICOLON       reduce using rule 41 (variable -> ID LBRACKET expression RBRACKET .)
    ELSE            reduce using rule 41 (variable -> ID LBRACKET expression RBRACKET .)
    RPAREN          reduce using rule 41 (variable -> ID LBRACKET expression RBRACKET .)
    COMMA           reduce using rule 41 (variable -> ID LBRACKET expression RBRACKET .)
    RBRACKET        reduce using rule 41 (variable -> ID LBRACKET expression RBRACKET .)
    TO              reduce using rule 41 (variable -> ID LBRACKET expression RBRACKET .)
    DOWNTO          reduce using rule 41 (variable -> ID LBRACKET expression RBRACKET .)

  ! TIMES           [ reduce using rule 92 (string_access -> ID LBRACKET expression RBRACKET .) ]
  ! DIVIDE          [ reduce using rule 92 (string_access -> ID LBRACKET expression RBRACKET .) ]
  ! DIV             [ reduce using rule 92 (string_access -> ID LBRACKET expression RBRACKET .) ]
  ! MOD             [ reduce using rule 92 (string_access -> ID LBRACKET expression RBRACKET .) ]
  ! AND             [ reduce using rule 92 (string_access -> ID LBRACKET expression RBRACKET .) ]
  ! EQ              [ reduce using rule 92 (string_access -> ID LBRACKET expression RBRACKET .) ]
  ! NEQ             [ reduce using rule 92 (string_access -> ID LBRACKET expression RBRACKET .) ]
  ! LT              [ reduce using rule 92 (string_access -> ID LBRACKET expression RBRACKET .) ]
  ! LE              [ reduce using rule 92 (string_access -> ID LBRACKET expression RBRACKET .) ]
  ! GT              [ reduce using rule 92 (string_access -> ID LBRACKET expression RBRACKET .) ]
  ! GE              [ reduce using rule 92 (string_access -> ID LBRACKET expression RBRACKET .) ]
  ! IN              [ reduce using rule 92 (string_access -> ID LBRACKET expression RBRACKET .) ]
  ! PLUS            [ reduce using rule 92 (string_access -> ID LBRACKET expression RBRACKET .) ]
  ! MINUS           [ reduce using rule 92 (string_access -> ID LBRACKET expression RBRACKET .) ]
  ! OR              [ reduce using rule 92 (string_access -> ID LBRACKET expression RBRACKET .) ]
  ! THEN            [ reduce using rule 92 (string_access -> ID LBRACKET expression RBRACKET .) ]
  ! DO              [ reduce using rule 92 (string_access -> ID LBRACKET expression RBRACKET .) ]
  ! END             [ reduce using rule 92 (string_access -> ID LBRACKET expression RBRACKET .) ]
  ! SEMICOLON       [ reduce using rule 92 (string_access -> ID LBRACKET expression RBRACKET .) ]
  ! ELSE            [ reduce using rule 92 (string_access -> ID LBRACKET expression RBRACKET .) ]
  ! RPAREN          [ reduce using rule 92 (string_access -> ID LBRACKET expression RBRACKET .) ]
  ! COMMA           [ reduce using rule 92 (string_access -> ID LBRACKET expression RBRACKET .) ]
  ! RBRACKET        [ reduce using rule 92 (string_access -> ID LBRACKET expression RBRACKET .) ]
  ! TO              [ reduce using rule 92 (string_access -> ID LBRACKET expression RBRACKET .) ]
  ! DOWNTO          [ reduce using rule 92 (string_access -> ID LBRACKET expression RBRACKET .) ]


state 177

    (95) function_call -> ID LPAREN expression_list RPAREN .

    TIMES           reduce using rule 95 (function_call -> ID LPAREN expression_list RPAREN .)
    DIVIDE          reduce using rule 95 (function_call -> ID LPAREN expression_list RPAREN .)
    DIV             reduce using rule 95 (function_call -> ID LPAREN expression_list RPAREN .)
    MOD             reduce using rule 95 (function_call -> ID LPAREN expression_list RPAREN .)
    AND             reduce using rule 95 (function_call -> ID LPAREN expression_list RPAREN .)
    EQ              reduce using rule 95 (function_call -> ID LPAREN expression_list RPAREN .)
    NEQ             reduce using rule 95 (function_call -> ID LPAREN expression_list RPAREN .)
    LT              reduce using rule 95 (function_call -> ID LPAREN expression_list RPAREN .)
    LE              reduce using rule 95 (function_call -> ID LPAREN expression_list RPAREN .)
    GT              reduce using rule 95 (function_call -> ID LPAREN expression_list RPAREN .)
    GE              reduce using rule 95 (function_call -> ID LPAREN expression_list RPAREN .)
    IN              reduce using rule 95 (function_call -> ID LPAREN expression_list RPAREN .)
    PLUS            reduce using rule 95 (function_call -> ID LPAREN expression_list RPAREN .)
    MINUS           reduce using rule 95 (function_call -> ID LPAREN expression_list RPAREN .)
    OR              reduce using rule 95 (function_call -> ID LPAREN expression_list RPAREN .)
    THEN            reduce using rule 95 (function_call -> ID LPAREN expression_list RPAREN .)
    DO              reduce using rule 95 (function_call -> ID LPAREN expression_list RPAREN .)
    END             reduce using rule 95 (function_call -> ID LPAREN expression_list RPAREN .)
    SEMICOLON       reduce using rule 95 (function_call -> ID LPAREN expression_list RPAREN .)
    ELSE            reduce using rule 95 (function_call -> ID LPAREN expression_list RPAREN .)
    RPAREN          reduce using rule 95 (function_call -> ID LPAREN expression_list RPAREN .)
    COMMA           reduce using rule 95 (function_call -> ID LPAREN expression_list RPAREN .)
    RBRACKET        reduce using rule 95 (function_call -> ID LPAREN expression_list RPAREN .)
    TO              reduce using rule 95 (function_call -> ID LPAREN expression_list RPAREN .)
    DOWNTO          reduce using rule 95 (function_call -> ID LPAREN expression_list RPAREN .)


state 178

    (92) string_access -> ID LBRACKET expression . RBRACKET
    (41) variable -> ID LBRACKET expression . RBRACKET

    RBRACKET        shift and go to state 188


state 179

    (45) for_statement -> FOR ID ASSIGN expression TO . expression DO statement
    (61) expression -> . simple_expression
    (62) expression -> . simple_expression relop simple_expression
    (93) expression -> . variable COLON INTEGER
    (94) expression -> . variable COLON INTEGER COLON INTEGER
    (70) simple_expression -> . term
    (71) simple_expression -> . simple_expression addop term
    (40) variable -> . ID
    (41) variable -> . ID LBRACKET expression RBRACKET
    (75) term -> . factor
    (76) term -> . term mulop factor
    (82) factor -> . string_access
    (83) factor -> . variable
    (84) factor -> . INTEGER
    (85) factor -> . REAL
    (86) factor -> . STRING
    (87) factor -> . TRUE
    (88) factor -> . FALSE
    (89) factor -> . LPAREN expression RPAREN
    (90) factor -> . NOT factor
    (91) factor -> . function_call
    (92) string_access -> . ID LBRACKET expression RBRACKET
    (95) function_call -> . ID LPAREN expression_list RPAREN
    (96) function_call -> . ID LPAREN RPAREN
    (97) function_call -> . LENGTH LPAREN expression RPAREN

    ID              shift and go to state 63
    INTEGER         shift and go to state 61
    REAL            shift and go to state 66
    STRING          shift and go to state 67
    TRUE            shift and go to state 68
    FALSE           shift and go to state 69
    LPAREN          shift and go to state 70
    NOT             shift and go to state 71
    LENGTH          shift and go to state 44

    expression                     shift and go to state 189
    simple_expression              shift and go to state 59
    variable                       shift and go to state 60
    term                           shift and go to state 62
    factor                         shift and go to state 64
    string_access                  shift and go to state 65
    function_call                  shift and go to state 72

state 180

    (46) for_statement -> FOR ID ASSIGN expression DOWNTO . expression DO statement
    (61) expression -> . simple_expression
    (62) expression -> . simple_expression relop simple_expression
    (93) expression -> . variable COLON INTEGER
    (94) expression -> . variable COLON INTEGER COLON INTEGER
    (70) simple_expression -> . term
    (71) simple_expression -> . simple_expression addop term
    (40) variable -> . ID
    (41) variable -> . ID LBRACKET expression RBRACKET
    (75) term -> . factor
    (76) term -> . term mulop factor
    (82) factor -> . string_access
    (83) factor -> . variable
    (84) factor -> . INTEGER
    (85) factor -> . REAL
    (86) factor -> . STRING
    (87) factor -> . TRUE
    (88) factor -> . FALSE
    (89) factor -> . LPAREN expression RPAREN
    (90) factor -> . NOT factor
    (91) factor -> . function_call
    (92) string_access -> . ID LBRACKET expression RBRACKET
    (95) function_call -> . ID LPAREN expression_list RPAREN
    (96) function_call -> . ID LPAREN RPAREN
    (97) function_call -> . LENGTH LPAREN expression RPAREN

    ID              shift and go to state 63
    INTEGER         shift and go to state 61
    REAL            shift and go to state 66
    STRING          shift and go to state 67
    TRUE            shift and go to state 68
    FALSE           shift and go to state 69
    LPAREN          shift and go to state 70
    NOT             shift and go to state 71
    LENGTH          shift and go to state 44

    expression                     shift and go to state 190
    simple_expression              shift and go to state 59
    variable                       shift and go to state 60
    term                           shift and go to state 62
    factor                         shift and go to state 64
    string_access                  shift and go to state 65
    function_call                  shift and go to state 72

state 181

    (25) array_type -> ARRAY LBRACKET INTEGER PERIOD . PERIOD INTEGER RBRACKET OF type_spec

    PERIOD          shift and go to state 191


state 182

    (10) function_declaration -> FUNCTION ID LPAREN param_list RPAREN COLON type_spec . SEMICOLON function_block SEMICOLON

    SEMICOLON       shift and go to state 192


state 183

    (60) param -> VAR id_list COLON type_spec .

    RPAREN          reduce using rule 60 (param -> VAR id_list COLON type_spec .)
    SEMICOLON       reduce using rule 60 (param -> VAR id_list COLON type_spec .)


state 184

    (11) function_declaration -> FUNCTION ID COLON type_spec SEMICOLON function_block SEMICOLON .

    VAR             reduce using rule 11 (function_declaration -> FUNCTION ID COLON type_spec SEMICOLON function_block SEMICOLON .)
    FUNCTION        reduce using rule 11 (function_declaration -> FUNCTION ID COLON type_spec SEMICOLON function_block SEMICOLON .)
    PROCEDURE       reduce using rule 11 (function_declaration -> FUNCTION ID COLON type_spec SEMICOLON function_block SEMICOLON .)
    BEGIN           reduce using rule 11 (function_declaration -> FUNCTION ID COLON type_spec SEMICOLON function_block SEMICOLON .)


state 185

    (12) procedure_declaration -> PROCEDURE ID LPAREN param_list RPAREN SEMICOLON function_block . SEMICOLON

    SEMICOLON       shift and go to state 193


state 186

    (43) if_statement -> IF expression THEN statement ELSE statement .

    END             reduce using rule 43 (if_statement -> IF expression THEN statement ELSE statement .)
    SEMICOLON       reduce using rule 43 (if_statement -> IF expression THEN statement ELSE statement .)
    ELSE            reduce using rule 43 (if_statement -> IF expression THEN statement ELSE statement .)


state 187

    (94) expression -> variable COLON INTEGER COLON INTEGER .

    THEN            reduce using rule 94 (expression -> variable COLON INTEGER COLON INTEGER .)
    DO              reduce using rule 94 (expression -> variable COLON INTEGER COLON INTEGER .)
    END             reduce using rule 94 (expression -> variable COLON INTEGER COLON INTEGER .)
    SEMICOLON       reduce using rule 94 (expression -> variable COLON INTEGER COLON INTEGER .)
    ELSE            reduce using rule 94 (expression -> variable COLON INTEGER COLON INTEGER .)
    RPAREN          reduce using rule 94 (expression -> variable COLON INTEGER COLON INTEGER .)
    COMMA           reduce using rule 94 (expression -> variable COLON INTEGER COLON INTEGER .)
    RBRACKET        reduce using rule 94 (expression -> variable COLON INTEGER COLON INTEGER .)
    TO              reduce using rule 94 (expression -> variable COLON INTEGER COLON INTEGER .)
    DOWNTO          reduce using rule 94 (expression -> variable COLON INTEGER COLON INTEGER .)


state 188

    (92) string_access -> ID LBRACKET expression RBRACKET .
    (41) variable -> ID LBRACKET expression RBRACKET .

  ! reduce/reduce conflict for TIMES resolved using rule 41 (variable -> ID LBRACKET expression RBRACKET .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 41 (variable -> ID LBRACKET expression RBRACKET .)
  ! reduce/reduce conflict for DIV resolved using rule 41 (variable -> ID LBRACKET expression RBRACKET .)
  ! reduce/reduce conflict for MOD resolved using rule 41 (variable -> ID LBRACKET expression RBRACKET .)
  ! reduce/reduce conflict for AND resolved using rule 41 (variable -> ID LBRACKET expression RBRACKET .)
  ! reduce/reduce conflict for EQ resolved using rule 41 (variable -> ID LBRACKET expression RBRACKET .)
  ! reduce/reduce conflict for NEQ resolved using rule 41 (variable -> ID LBRACKET expression RBRACKET .)
  ! reduce/reduce conflict for LT resolved using rule 41 (variable -> ID LBRACKET expression RBRACKET .)
  ! reduce/reduce conflict for LE resolved using rule 41 (variable -> ID LBRACKET expression RBRACKET .)
  ! reduce/reduce conflict for GT resolved using rule 41 (variable -> ID LBRACKET expression RBRACKET .)
  ! reduce/reduce conflict for GE resolved using rule 41 (variable -> ID LBRACKET expression RBRACKET .)
  ! reduce/reduce conflict for IN resolved using rule 41 (variable -> ID LBRACKET expression RBRACKET .)
  ! reduce/reduce conflict for PLUS resolved using rule 41 (variable -> ID LBRACKET expression RBRACKET .)
  ! reduce/reduce conflict for MINUS resolved using rule 41 (variable -> ID LBRACKET expression RBRACKET .)
  ! reduce/reduce conflict for OR resolved using rule 41 (variable -> ID LBRACKET expression RBRACKET .)
  ! reduce/reduce conflict for THEN resolved using rule 41 (variable -> ID LBRACKET expression RBRACKET .)
  ! reduce/reduce conflict for DO resolved using rule 41 (variable -> ID LBRACKET expression RBRACKET .)
  ! reduce/reduce conflict for END resolved using rule 41 (variable -> ID LBRACKET expression RBRACKET .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 41 (variable -> ID LBRACKET expression RBRACKET .)
  ! reduce/reduce conflict for ELSE resolved using rule 41 (variable -> ID LBRACKET expression RBRACKET .)
  ! reduce/reduce conflict for RPAREN resolved using rule 41 (variable -> ID LBRACKET expression RBRACKET .)
  ! reduce/reduce conflict for COMMA resolved using rule 41 (variable -> ID LBRACKET expression RBRACKET .)
  ! reduce/reduce conflict for RBRACKET resolved using rule 41 (variable -> ID LBRACKET expression RBRACKET .)
  ! reduce/reduce conflict for TO resolved using rule 41 (variable -> ID LBRACKET expression RBRACKET .)
  ! reduce/reduce conflict for DOWNTO resolved using rule 41 (variable -> ID LBRACKET expression RBRACKET .)
    TIMES           reduce using rule 41 (variable -> ID LBRACKET expression RBRACKET .)
    DIVIDE          reduce using rule 41 (variable -> ID LBRACKET expression RBRACKET .)
    DIV             reduce using rule 41 (variable -> ID LBRACKET expression RBRACKET .)
    MOD             reduce using rule 41 (variable -> ID LBRACKET expression RBRACKET .)
    AND             reduce using rule 41 (variable -> ID LBRACKET expression RBRACKET .)
    EQ              reduce using rule 41 (variable -> ID LBRACKET expression RBRACKET .)
    NEQ             reduce using rule 41 (variable -> ID LBRACKET expression RBRACKET .)
    LT              reduce using rule 41 (variable -> ID LBRACKET expression RBRACKET .)
    LE              reduce using rule 41 (variable -> ID LBRACKET expression RBRACKET .)
    GT              reduce using rule 41 (variable -> ID LBRACKET expression RBRACKET .)
    GE              reduce using rule 41 (variable -> ID LBRACKET expression RBRACKET .)
    IN              reduce using rule 41 (variable -> ID LBRACKET expression RBRACKET .)
    PLUS            reduce using rule 41 (variable -> ID LBRACKET expression RBRACKET .)
    MINUS           reduce using rule 41 (variable -> ID LBRACKET expression RBRACKET .)
    OR              reduce using rule 41 (variable -> ID LBRACKET expression RBRACKET .)
    THEN            reduce using rule 41 (variable -> ID LBRACKET expression RBRACKET .)
    DO              reduce using rule 41 (variable -> ID LBRACKET expression RBRACKET .)
    END             reduce using rule 41 (variable -> ID LBRACKET expression RBRACKET .)
    SEMICOLON       reduce using rule 41 (variable -> ID LBRACKET expression RBRACKET .)
    ELSE            reduce using rule 41 (variable -> ID LBRACKET expression RBRACKET .)
    RPAREN          reduce using rule 41 (variable -> ID LBRACKET expression RBRACKET .)
    COMMA           reduce using rule 41 (variable -> ID LBRACKET expression RBRACKET .)
    RBRACKET        reduce using rule 41 (variable -> ID LBRACKET expression RBRACKET .)
    TO              reduce using rule 41 (variable -> ID LBRACKET expression RBRACKET .)
    DOWNTO          reduce using rule 41 (variable -> ID LBRACKET expression RBRACKET .)

  ! TIMES           [ reduce using rule 92 (string_access -> ID LBRACKET expression RBRACKET .) ]
  ! DIVIDE          [ reduce using rule 92 (string_access -> ID LBRACKET expression RBRACKET .) ]
  ! DIV             [ reduce using rule 92 (string_access -> ID LBRACKET expression RBRACKET .) ]
  ! MOD             [ reduce using rule 92 (string_access -> ID LBRACKET expression RBRACKET .) ]
  ! AND             [ reduce using rule 92 (string_access -> ID LBRACKET expression RBRACKET .) ]
  ! EQ              [ reduce using rule 92 (string_access -> ID LBRACKET expression RBRACKET .) ]
  ! NEQ             [ reduce using rule 92 (string_access -> ID LBRACKET expression RBRACKET .) ]
  ! LT              [ reduce using rule 92 (string_access -> ID LBRACKET expression RBRACKET .) ]
  ! LE              [ reduce using rule 92 (string_access -> ID LBRACKET expression RBRACKET .) ]
  ! GT              [ reduce using rule 92 (string_access -> ID LBRACKET expression RBRACKET .) ]
  ! GE              [ reduce using rule 92 (string_access -> ID LBRACKET expression RBRACKET .) ]
  ! IN              [ reduce using rule 92 (string_access -> ID LBRACKET expression RBRACKET .) ]
  ! PLUS            [ reduce using rule 92 (string_access -> ID LBRACKET expression RBRACKET .) ]
  ! MINUS           [ reduce using rule 92 (string_access -> ID LBRACKET expression RBRACKET .) ]
  ! OR              [ reduce using rule 92 (string_access -> ID LBRACKET expression RBRACKET .) ]
  ! THEN            [ reduce using rule 92 (string_access -> ID LBRACKET expression RBRACKET .) ]
  ! DO              [ reduce using rule 92 (string_access -> ID LBRACKET expression RBRACKET .) ]
  ! END             [ reduce using rule 92 (string_access -> ID LBRACKET expression RBRACKET .) ]
  ! SEMICOLON       [ reduce using rule 92 (string_access -> ID LBRACKET expression RBRACKET .) ]
  ! ELSE            [ reduce using rule 92 (string_access -> ID LBRACKET expression RBRACKET .) ]
  ! RPAREN          [ reduce using rule 92 (string_access -> ID LBRACKET expression RBRACKET .) ]
  ! COMMA           [ reduce using rule 92 (string_access -> ID LBRACKET expression RBRACKET .) ]
  ! RBRACKET        [ reduce using rule 92 (string_access -> ID LBRACKET expression RBRACKET .) ]
  ! TO              [ reduce using rule 92 (string_access -> ID LBRACKET expression RBRACKET .) ]
  ! DOWNTO          [ reduce using rule 92 (string_access -> ID LBRACKET expression RBRACKET .) ]


state 189

    (45) for_statement -> FOR ID ASSIGN expression TO expression . DO statement

    DO              shift and go to state 194


state 190

    (46) for_statement -> FOR ID ASSIGN expression DOWNTO expression . DO statement

    DO              shift and go to state 195


state 191

    (25) array_type -> ARRAY LBRACKET INTEGER PERIOD PERIOD . INTEGER RBRACKET OF type_spec

    INTEGER         shift and go to state 196


state 192

    (10) function_declaration -> FUNCTION ID LPAREN param_list RPAREN COLON type_spec SEMICOLON . function_block SEMICOLON
    (8) function_block -> . declarations compound_statement
    (9) function_block -> . compound_statement
    (3) declarations -> . declaration declarations
    (4) declarations -> . empty
    (26) compound_statement -> . BEGIN statement_list END
    (5) declaration -> . VAR var_declarations
    (6) declaration -> . function_declaration
    (7) declaration -> . procedure_declaration
    (99) empty -> .
    (10) function_declaration -> . FUNCTION ID LPAREN param_list RPAREN COLON type_spec SEMICOLON function_block SEMICOLON
    (11) function_declaration -> . FUNCTION ID COLON type_spec SEMICOLON function_block SEMICOLON
    (12) procedure_declaration -> . PROCEDURE ID LPAREN param_list RPAREN SEMICOLON function_block SEMICOLON
    (13) procedure_declaration -> . PROCEDURE ID SEMICOLON function_block SEMICOLON

  ! shift/reduce conflict for BEGIN resolved as shift
    BEGIN           shift and go to state 16
    VAR             shift and go to state 9
    FUNCTION        shift and go to state 12
    PROCEDURE       shift and go to state 13

  ! BEGIN           [ reduce using rule 99 (empty -> .) ]

    function_block                 shift and go to state 197
    declarations                   shift and go to state 95
    compound_statement             shift and go to state 96
    declaration                    shift and go to state 7
    empty                          shift and go to state 8
    function_declaration           shift and go to state 10
    procedure_declaration          shift and go to state 11

state 193

    (12) procedure_declaration -> PROCEDURE ID LPAREN param_list RPAREN SEMICOLON function_block SEMICOLON .

    VAR             reduce using rule 12 (procedure_declaration -> PROCEDURE ID LPAREN param_list RPAREN SEMICOLON function_block SEMICOLON .)
    FUNCTION        reduce using rule 12 (procedure_declaration -> PROCEDURE ID LPAREN param_list RPAREN SEMICOLON function_block SEMICOLON .)
    PROCEDURE       reduce using rule 12 (procedure_declaration -> PROCEDURE ID LPAREN param_list RPAREN SEMICOLON function_block SEMICOLON .)
    BEGIN           reduce using rule 12 (procedure_declaration -> PROCEDURE ID LPAREN param_list RPAREN SEMICOLON function_block SEMICOLON .)


state 194

    (45) for_statement -> FOR ID ASSIGN expression TO expression DO . statement
    (29) statement -> . compound_statement
    (30) statement -> . assignment_statement
    (31) statement -> . if_statement
    (32) statement -> . while_statement
    (33) statement -> . for_statement
    (34) statement -> . procedure_call_statement
    (35) statement -> . function_call_statement
    (36) statement -> . halt_statement
    (37) statement -> . empty
    (26) compound_statement -> . BEGIN statement_list END
    (38) assignment_statement -> . variable ASSIGN expression
    (39) assignment_statement -> . ID ASSIGN expression
    (42) if_statement -> . IF expression THEN statement
    (43) if_statement -> . IF expression THEN statement ELSE statement
    (44) while_statement -> . WHILE expression DO statement
    (45) for_statement -> . FOR ID ASSIGN expression TO expression DO statement
    (46) for_statement -> . FOR ID ASSIGN expression DOWNTO expression DO statement
    (47) procedure_call_statement -> . ID LPAREN expression_list RPAREN
    (48) procedure_call_statement -> . ID LPAREN RPAREN
    (49) procedure_call_statement -> . WRITELN LPAREN expression_list RPAREN
    (50) procedure_call_statement -> . WRITELN LPAREN RPAREN
    (51) procedure_call_statement -> . READLN LPAREN variable RPAREN
    (52) procedure_call_statement -> . READLN LPAREN RPAREN
    (53) function_call_statement -> . function_call
    (98) halt_statement -> . HALT
    (99) empty -> .
    (40) variable -> . ID
    (41) variable -> . ID LBRACKET expression RBRACKET
    (95) function_call -> . ID LPAREN expression_list RPAREN
    (96) function_call -> . ID LPAREN RPAREN
    (97) function_call -> . LENGTH LPAREN expression RPAREN

    BEGIN           shift and go to state 16
    ID              shift and go to state 36
    IF              shift and go to state 37
    WHILE           shift and go to state 38
    FOR             shift and go to state 39
    WRITELN         shift and go to state 40
    READLN          shift and go to state 41
    HALT            shift and go to state 43
    ELSE            reduce using rule 99 (empty -> .)
    END             reduce using rule 99 (empty -> .)
    SEMICOLON       reduce using rule 99 (empty -> .)
    LENGTH          shift and go to state 44

    statement                      shift and go to state 198
    compound_statement             shift and go to state 26
    assignment_statement           shift and go to state 27
    if_statement                   shift and go to state 28
    while_statement                shift and go to state 29
    for_statement                  shift and go to state 30
    procedure_call_statement       shift and go to state 31
    function_call_statement        shift and go to state 32
    halt_statement                 shift and go to state 33
    empty                          shift and go to state 34
    variable                       shift and go to state 35
    function_call                  shift and go to state 42

state 195

    (46) for_statement -> FOR ID ASSIGN expression DOWNTO expression DO . statement
    (29) statement -> . compound_statement
    (30) statement -> . assignment_statement
    (31) statement -> . if_statement
    (32) statement -> . while_statement
    (33) statement -> . for_statement
    (34) statement -> . procedure_call_statement
    (35) statement -> . function_call_statement
    (36) statement -> . halt_statement
    (37) statement -> . empty
    (26) compound_statement -> . BEGIN statement_list END
    (38) assignment_statement -> . variable ASSIGN expression
    (39) assignment_statement -> . ID ASSIGN expression
    (42) if_statement -> . IF expression THEN statement
    (43) if_statement -> . IF expression THEN statement ELSE statement
    (44) while_statement -> . WHILE expression DO statement
    (45) for_statement -> . FOR ID ASSIGN expression TO expression DO statement
    (46) for_statement -> . FOR ID ASSIGN expression DOWNTO expression DO statement
    (47) procedure_call_statement -> . ID LPAREN expression_list RPAREN
    (48) procedure_call_statement -> . ID LPAREN RPAREN
    (49) procedure_call_statement -> . WRITELN LPAREN expression_list RPAREN
    (50) procedure_call_statement -> . WRITELN LPAREN RPAREN
    (51) procedure_call_statement -> . READLN LPAREN variable RPAREN
    (52) procedure_call_statement -> . READLN LPAREN RPAREN
    (53) function_call_statement -> . function_call
    (98) halt_statement -> . HALT
    (99) empty -> .
    (40) variable -> . ID
    (41) variable -> . ID LBRACKET expression RBRACKET
    (95) function_call -> . ID LPAREN expression_list RPAREN
    (96) function_call -> . ID LPAREN RPAREN
    (97) function_call -> . LENGTH LPAREN expression RPAREN

    BEGIN           shift and go to state 16
    ID              shift and go to state 36
    IF              shift and go to state 37
    WHILE           shift and go to state 38
    FOR             shift and go to state 39
    WRITELN         shift and go to state 40
    READLN          shift and go to state 41
    HALT            shift and go to state 43
    ELSE            reduce using rule 99 (empty -> .)
    END             reduce using rule 99 (empty -> .)
    SEMICOLON       reduce using rule 99 (empty -> .)
    LENGTH          shift and go to state 44

    statement                      shift and go to state 199
    compound_statement             shift and go to state 26
    assignment_statement           shift and go to state 27
    if_statement                   shift and go to state 28
    while_statement                shift and go to state 29
    for_statement                  shift and go to state 30
    procedure_call_statement       shift and go to state 31
    function_call_statement        shift and go to state 32
    halt_statement                 shift and go to state 33
    empty                          shift and go to state 34
    variable                       shift and go to state 35
    function_call                  shift and go to state 42

state 196

    (25) array_type -> ARRAY LBRACKET INTEGER PERIOD PERIOD INTEGER . RBRACKET OF type_spec

    RBRACKET        shift and go to state 200


state 197

    (10) function_declaration -> FUNCTION ID LPAREN param_list RPAREN COLON type_spec SEMICOLON function_block . SEMICOLON

    SEMICOLON       shift and go to state 201


state 198

    (45) for_statement -> FOR ID ASSIGN expression TO expression DO statement .

    END             reduce using rule 45 (for_statement -> FOR ID ASSIGN expression TO expression DO statement .)
    SEMICOLON       reduce using rule 45 (for_statement -> FOR ID ASSIGN expression TO expression DO statement .)
    ELSE            reduce using rule 45 (for_statement -> FOR ID ASSIGN expression TO expression DO statement .)


state 199

    (46) for_statement -> FOR ID ASSIGN expression DOWNTO expression DO statement .

    END             reduce using rule 46 (for_statement -> FOR ID ASSIGN expression DOWNTO expression DO statement .)
    SEMICOLON       reduce using rule 46 (for_statement -> FOR ID ASSIGN expression DOWNTO expression DO statement .)
    ELSE            reduce using rule 46 (for_statement -> FOR ID ASSIGN expression DOWNTO expression DO statement .)


state 200

    (25) array_type -> ARRAY LBRACKET INTEGER PERIOD PERIOD INTEGER RBRACKET . OF type_spec

    OF              shift and go to state 202


state 201

    (10) function_declaration -> FUNCTION ID LPAREN param_list RPAREN COLON type_spec SEMICOLON function_block SEMICOLON .

    VAR             reduce using rule 10 (function_declaration -> FUNCTION ID LPAREN param_list RPAREN COLON type_spec SEMICOLON function_block SEMICOLON .)
    FUNCTION        reduce using rule 10 (function_declaration -> FUNCTION ID LPAREN param_list RPAREN COLON type_spec SEMICOLON function_block SEMICOLON .)
    PROCEDURE       reduce using rule 10 (function_declaration -> FUNCTION ID LPAREN param_list RPAREN COLON type_spec SEMICOLON function_block SEMICOLON .)
    BEGIN           reduce using rule 10 (function_declaration -> FUNCTION ID LPAREN param_list RPAREN COLON type_spec SEMICOLON function_block SEMICOLON .)


state 202

    (25) array_type -> ARRAY LBRACKET INTEGER PERIOD PERIOD INTEGER RBRACKET OF . type_spec
    (19) type_spec -> . INTEGER_TYPE
    (20) type_spec -> . REAL_TYPE
    (21) type_spec -> . BOOLEAN
    (22) type_spec -> . STRING_TYPE
    (23) type_spec -> . CHAR_TYPE
    (24) type_spec -> . array_type
    (25) array_type -> . ARRAY LBRACKET INTEGER PERIOD PERIOD INTEGER RBRACKET OF type_spec

    INTEGER_TYPE    shift and go to state 79
    REAL_TYPE       shift and go to state 80
    BOOLEAN         shift and go to state 81
    STRING_TYPE     shift and go to state 82
    CHAR_TYPE       shift and go to state 83
    ARRAY           shift and go to state 85

    type_spec                      shift and go to state 203
    array_type                     shift and go to state 84

state 203

    (25) array_type -> ARRAY LBRACKET INTEGER PERIOD PERIOD INTEGER RBRACKET OF type_spec .

    SEMICOLON       reduce using rule 25 (array_type -> ARRAY LBRACKET INTEGER PERIOD PERIOD INTEGER RBRACKET OF type_spec .)
    RPAREN          reduce using rule 25 (array_type -> ARRAY LBRACKET INTEGER PERIOD PERIOD INTEGER RBRACKET OF type_spec .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for ASSIGN in state 36 resolved as shift
WARNING: shift/reduce conflict for BEGIN in state 51 resolved as shift
WARNING: shift/reduce conflict for BEGIN in state 144 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 151 resolved as shift
WARNING: shift/reduce conflict for BEGIN in state 172 resolved as shift
WARNING: shift/reduce conflict for BEGIN in state 192 resolved as shift
WARNING: reduce/reduce conflict in state 101 resolved using rule (procedure_call_statement -> ID LPAREN RPAREN)
WARNING: rejected rule (function_call -> ID LPAREN RPAREN) in state 101
WARNING: reduce/reduce conflict in state 148 resolved using rule (procedure_call_statement -> ID LPAREN expression_list RPAREN)
WARNING: rejected rule (function_call -> ID LPAREN expression_list RPAREN) in state 148
WARNING: reduce/reduce conflict in state 176 resolved using rule (variable -> ID LBRACKET expression RBRACKET)
WARNING: rejected rule (string_access -> ID LBRACKET expression RBRACKET) in state 176
WARNING: reduce/reduce conflict in state 188 resolved using rule (variable -> ID LBRACKET expression RBRACKET)
WARNING: rejected rule (string_access -> ID LBRACKET expression RBRACKET) in state 188
WARNING: Rule (string_access -> ID LBRACKET expression RBRACKET) is never reduced
